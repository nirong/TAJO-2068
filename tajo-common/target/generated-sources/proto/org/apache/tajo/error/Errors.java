// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: errors.proto

package org.apache.tajo.error;

public final class Errors {
  private Errors() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code tajo.error.ResultCode}
   */
  public enum ResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>OK = 0;</code>
     *
     * <pre>
     * Class
     * 00 - Successful Completion
     * </pre>
     */
    OK(0, 0),
    /**
     * <code>WARNING = 100;</code>
     *
     * <pre>
     * Warning
     * </pre>
     */
    WARNING(1, 100),
    /**
     * <code>INTERNAL_ERROR = 201;</code>
     *
     * <pre>
     * General Errors
     * </pre>
     */
    INTERNAL_ERROR(2, 201),
    /**
     * <code>NOT_IMPLEMENTED = 202;</code>
     *
     * <pre>
     * SQLState: 0A000 - Not implemented yet, but planned.
     * </pre>
     */
    NOT_IMPLEMENTED(3, 202),
    /**
     * <code>FEATURE_NOT_SUPPORTED = 203;</code>
     *
     * <pre>
     * SQLState: 0A000 - Unsupported feature (usually for unreasonable feature)
     * </pre>
     */
    FEATURE_NOT_SUPPORTED(4, 203),
    /**
     * <code>INVALID_RPC_CALL = 204;</code>
     *
     * <pre>
     * SQLState: 08P01 - When invalid RPC call is invoked (e.g., wrong message and absent fields)
     * </pre>
     */
    INVALID_RPC_CALL(5, 204),
    /**
     * <code>QUERY_FAILED = 301;</code>
     *
     * <pre>
     * Query Management and Scheduler
     * </pre>
     */
    QUERY_FAILED(6, 301),
    /**
     * <code>QUERY_KILLED = 302;</code>
     *
     * <pre>
     * SQLState: 61T02 - Query killed
     * </pre>
     */
    QUERY_KILLED(7, 302),
    /**
     * <code>QUERY_TIMEOUT = 303;</code>
     *
     * <pre>
     * SQLState: 61T03 - Timeout for the query
     * </pre>
     */
    QUERY_TIMEOUT(8, 303),
    /**
     * <code>QUERY_NOT_FOUND = 304;</code>
     *
     * <pre>
     * SQLState: 61T04 - No such query in TajoMaster
     * </pre>
     */
    QUERY_NOT_FOUND(9, 304),
    /**
     * <code>NO_DATA = 305;</code>
     *
     * <pre>
     * SQLState: 61T05 - No data due to query fail or error
     * </pre>
     */
    NO_DATA(10, 305),
    /**
     * <code>INCOMPLETE_QUERY = 306;</code>
     *
     * <pre>
     * SQLState: 61T06 - It occurs when a client requests something of a completed query.
     * </pre>
     */
    INCOMPLETE_QUERY(11, 306),
    /**
     * <code>INVALID_SESSION = 401;</code>
     *
     * <pre>
     * Session
     * </pre>
     */
    INVALID_SESSION(12, 401),
    /**
     * <code>NO_SUCH_SESSION_VARIABLE = 402;</code>
     *
     * <pre>
     * SQLState: 62T01 - Session variable not found
     * </pre>
     */
    NO_SUCH_SESSION_VARIABLE(13, 402),
    /**
     * <code>INVALID_SESSION_VARIABLE = 403;</code>
     *
     * <pre>
     * SQLState: 62T01 - Session variable is invalid (type mismatch or out of range)
     * </pre>
     */
    INVALID_SESSION_VARIABLE(14, 403),
    /**
     * <code>DIVISION_BY_ZERO = 451;</code>
     *
     * <pre>
     * Data Exception (SQLState Class - 22)
     * </pre>
     */
    DIVISION_BY_ZERO(15, 451),
    /**
     * <code>INVALID_VALUE_FOR_CAST = 452;</code>
     *
     * <pre>
     * SQLState: 22T01 - Invalid data value for cast
     * </pre>
     */
    INVALID_VALUE_FOR_CAST(16, 452),
    /**
     * <code>INVALID_URL = 453;</code>
     *
     * <pre>
     * SQLState: 22T02 - Invalid URL
     * </pre>
     */
    INVALID_URL(17, 453),
    /**
     * <code>SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION = 501;</code>
     *
     * <pre>
     * Section: Class 42 - Syntax Error or Access Rule Violation
     * </pre>
     */
    SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION(18, 501),
    /**
     * <code>SYNTAX_ERROR = 502;</code>
     *
     * <pre>
     * SQLState: 42601
     * </pre>
     */
    SYNTAX_ERROR(19, 502),
    /**
     * <code>INSUFFICIENT_PRIVILEGE = 503;</code>
     *
     * <pre>
     * SQLState: 42501
     * </pre>
     */
    INSUFFICIENT_PRIVILEGE(20, 503),
    /**
     * <code>CANNOT_DROP_CURRENT_DATABASE = 504;</code>
     *
     * <pre>
     * SQLState: 42T01
     * </pre>
     */
    CANNOT_DROP_CURRENT_DATABASE(21, 504),
    /**
     * <code>UNDEFINED_TABLESPACE = 511;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_TABLESPACE(22, 511),
    /**
     * <code>UNDEFINED_DATABASE = 512;</code>
     *
     * <pre>
     * SQLState: 42T02
     * </pre>
     */
    UNDEFINED_DATABASE(23, 512),
    /**
     * <code>UNDEFINED_SCHEMA = 513;</code>
     *
     * <pre>
     * SQLState:
     * </pre>
     */
    UNDEFINED_SCHEMA(24, 513),
    /**
     * <code>UNDEFINED_TABLE = 514;</code>
     *
     * <pre>
     * SQLState: 42P01
     * </pre>
     */
    UNDEFINED_TABLE(25, 514),
    /**
     * <code>UNDEFINED_COLUMN = 515;</code>
     *
     * <pre>
     * SQLState: 42703
     * </pre>
     */
    UNDEFINED_COLUMN(26, 515),
    /**
     * <code>UNDEFINED_FUNCTION = 516;</code>
     *
     * <pre>
     * SQLState: 42883
     * </pre>
     */
    UNDEFINED_FUNCTION(27, 516),
    /**
     * <code>UNDEFINED_INDEX_FOR_TABLE = 517;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_INDEX_FOR_TABLE(28, 517),
    /**
     * <code>UNDEFINED_INDEX_FOR_COLUMNS = 518;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_INDEX_FOR_COLUMNS(29, 518),
    /**
     * <code>UNDEFINED_INDEX_NAME = 519;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_INDEX_NAME(30, 519),
    /**
     * <code>UNDEFINED_PARTITION = 520;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_PARTITION(31, 520),
    /**
     * <code>UNDEFINED_PARTITION_METHOD = 521;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_PARTITION_METHOD(32, 521),
    /**
     * <code>UNDEFINED_OPERATOR = 522;</code>
     *
     * <pre>
     * SQLState: 42883 (=UNDEFINED_FUNCTION)
     * </pre>
     */
    UNDEFINED_OPERATOR(33, 522),
    /**
     * <code>UNDEFINED_PARTITION_KEY = 523;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_PARTITION_KEY(34, 523),
    /**
     * <code>UNDEFINED_TABLESPACE_HANDLER = 524;</code>
     *
     * <pre>
     * SQLState: 42T11 - No Tablespace Handler for the URI scheme
     * </pre>
     */
    UNDEFINED_TABLESPACE_HANDLER(35, 524),
    /**
     * <code>UNDEFINED_PARTITIONS = 525;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    UNDEFINED_PARTITIONS(36, 525),
    /**
     * <code>DUPLICATE_TABLESPACE = 531;</code>
     */
    DUPLICATE_TABLESPACE(37, 531),
    /**
     * <code>DUPLICATE_DATABASE = 532;</code>
     *
     * <pre>
     * SQLState: 42P04
     * </pre>
     */
    DUPLICATE_DATABASE(38, 532),
    /**
     * <code>DUPLICATE_SCHEMA = 533;</code>
     *
     * <pre>
     * SQLState: 42P06
     * </pre>
     */
    DUPLICATE_SCHEMA(39, 533),
    /**
     * <code>DUPLICATE_TABLE = 534;</code>
     *
     * <pre>
     * SQLState: 42P07
     * </pre>
     */
    DUPLICATE_TABLE(40, 534),
    /**
     * <code>DUPLICATE_COLUMN = 535;</code>
     *
     * <pre>
     * SQLState: 42701
     * </pre>
     */
    DUPLICATE_COLUMN(41, 535),
    /**
     * <code>DUPLICATE_ALIAS = 536;</code>
     *
     * <pre>
     * SQLState: 42712
     * </pre>
     */
    DUPLICATE_ALIAS(42, 536),
    /**
     * <code>DUPLICATE_FUNCTION = 537;</code>
     *
     * <pre>
     * SQLState: 42723
     * </pre>
     */
    DUPLICATE_FUNCTION(43, 537),
    /**
     * <code>DUPLICATE_INDEX = 538;</code>
     *
     * <pre>
     * SQLState: 42T07
     * </pre>
     */
    DUPLICATE_INDEX(44, 538),
    /**
     * <code>DUPLICATE_PARTITION = 539;</code>
     *
     * <pre>
     * SQLState: 42T08
     * </pre>
     */
    DUPLICATE_PARTITION(45, 539),
    /**
     * <code>AMBIGUOUS_TABLE = 541;</code>
     *
     * <pre>
     * SQLState: 42P09
     * </pre>
     */
    AMBIGUOUS_TABLE(46, 541),
    /**
     * <code>AMBIGUOUS_COLUMN = 542;</code>
     *
     * <pre>
     * SQLState: 42702;
     * </pre>
     */
    AMBIGUOUS_COLUMN(47, 542),
    /**
     * <code>AMBIGUOUS_FUNCTION = 543;</code>
     *
     * <pre>
     * SQLState: 42725;
     * </pre>
     */
    AMBIGUOUS_FUNCTION(48, 543),
    /**
     * <code>AMBIGUOUS_PARTITION_DIRECTORY = 544;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    AMBIGUOUS_PARTITION_DIRECTORY(49, 544),
    /**
     * <code>CANNOT_CAST = 601;</code>
     *
     * <pre>
     * SQLState: 42846 - Cast from source type to target type is not supported.
     * </pre>
     */
    CANNOT_CAST(50, 601),
    /**
     * <code>GROUPING_ERROR = 602;</code>
     *
     * <pre>
     * SQLState: 42803
     * </pre>
     */
    GROUPING_ERROR(51, 602),
    /**
     * <code>WINDOWING_ERROR = 603;</code>
     *
     * <pre>
     * SQLState: 42P20 - PgSQL implementation-defined
     * </pre>
     */
    WINDOWING_ERROR(52, 603),
    /**
     * <code>INVALID_RECURSION = 604;</code>
     *
     * <pre>
     * SQLState: 42P19 - PgSQL implementation-defined
     * </pre>
     */
    INVALID_RECURSION(53, 604),
    /**
     * <code>SET_OPERATION_SCHEMA_MISMATCH = 605;</code>
     *
     * <pre>
     * SQLState: 42601 (=SYNTAX_ERROR)
     * </pre>
     */
    SET_OPERATION_SCHEMA_MISMATCH(54, 605),
    /**
     * <code>SET_OPERATION_DATATYPE_MISMATCH = 606;</code>
     *
     * <pre>
     * SQLState: 42601 (=SYNTAX_ERROR)
     * </pre>
     */
    SET_OPERATION_DATATYPE_MISMATCH(55, 606),
    /**
     * <code>INVALID_FOREIGN_KEY = 621;</code>
     *
     * <pre>
     * SQLState: 42830
     * </pre>
     */
    INVALID_FOREIGN_KEY(56, 621),
    /**
     * <code>INVALID_NAME = 622;</code>
     *
     * <pre>
     * SQLState: 42602
     * </pre>
     */
    INVALID_NAME(57, 622),
    /**
     * <code>INVALID_COLUMN_DEFINITION = 623;</code>
     *
     * <pre>
     * SQLState: 42611
     * </pre>
     */
    INVALID_COLUMN_DEFINITION(58, 623),
    /**
     * <code>NAME_TOO_LONG = 624;</code>
     *
     * <pre>
     * SQLState: 42622
     * </pre>
     */
    NAME_TOO_LONG(59, 624),
    /**
     * <code>RESERVED_NAME = 625;</code>
     *
     * <pre>
     * SQLState: 42939
     * </pre>
     */
    RESERVED_NAME(60, 625),
    /**
     * <code>DATATYPE_MISMATCH = 626;</code>
     *
     * <pre>
     * SQLState: 42804
     * </pre>
     */
    DATATYPE_MISMATCH(61, 626),
    /**
     * <code>INDETERMINATE_DATATYPE = 627;</code>
     *
     * <pre>
     * SQLState: 42P18 - PgSQL implementation -defined
     * </pre>
     */
    INDETERMINATE_DATATYPE(62, 627),
    /**
     * <code>INVALID_EXPRESSION = 701;</code>
     *
     * <pre>
     * Expressions
     * </pre>
     */
    INVALID_EXPRESSION(63, 701),
    /**
     * <code>INVALID_DATATYPE = 703;</code>
     */
    INVALID_DATATYPE(64, 703),
    /**
     * <code>NUMERIC_OVERFLOW = 803;</code>
     *
     * <pre>
     * Numeric value overflow
     * </pre>
     */
    NUMERIC_OVERFLOW(65, 803),
    /**
     * <code>VALUE_LARGER_THAN_PRECISION = 804;</code>
     *
     * <pre>
     * Value larger than column precision
     * </pre>
     */
    VALUE_LARGER_THAN_PRECISION(66, 804),
    /**
     * <code>CAT_UPGRADE_REQUIRED = 901;</code>
     *
     * <pre>
     * Meta Catalog
     * </pre>
     */
    CAT_UPGRADE_REQUIRED(67, 901),
    /**
     * <code>CAT_CANNOT_CONNECT = 902;</code>
     *
     * <pre>
     * Cannot connect metadata server
     * </pre>
     */
    CAT_CANNOT_CONNECT(68, 902),
    /**
     * <code>CAT_UNSUPPORTED_CATALOG_STORE = 905;</code>
     *
     * <pre>
     * Catalog store
     * </pre>
     */
    CAT_UNSUPPORTED_CATALOG_STORE(69, 905),
    /**
     * <code>LMD_NO_MATCHED_DATATYPE = 910;</code>
     *
     * <pre>
     * Linked Metadata (LMD)
     * </pre>
     */
    LMD_NO_MATCHED_DATATYPE(70, 910),
    /**
     * <code>UNAVAILABLE_TABLE_LOCATION = 1001;</code>
     *
     * <pre>
     * Storage and Data Format
     * </pre>
     */
    UNAVAILABLE_TABLE_LOCATION(71, 1001),
    /**
     * <code>UNKNOWN_DATAFORMAT = 1002;</code>
     *
     * <pre>
     * SQLState: ? - Unknown Data Format
     * </pre>
     */
    UNKNOWN_DATAFORMAT(72, 1002),
    /**
     * <code>UNSUPPORTED_DATATYPE = 1003;</code>
     *
     * <pre>
     * SQLState: ? - Unsupported data type
     * </pre>
     */
    UNSUPPORTED_DATATYPE(73, 1003),
    /**
     * <code>INVALID_TABLE_PROPERTY = 1004;</code>
     *
     * <pre>
     * SQLState: ? - Invalid Table Property
     * </pre>
     */
    INVALID_TABLE_PROPERTY(74, 1004),
    /**
     * <code>MISSING_TABLE_PROPERTY = 1005;</code>
     *
     * <pre>
     * SQLState: ? - Missing table property
     * </pre>
     */
    MISSING_TABLE_PROPERTY(75, 1005),
    /**
     * <code>CLIENT_CONNECTION_EXCEPTION = 1101;</code>
     *
     * <pre>
     * Client Connection
     * </pre>
     */
    CLIENT_CONNECTION_EXCEPTION(76, 1101),
    /**
     * <code>CLIENT_CONNECTION_DOES_NOT_EXIST = 1103;</code>
     *
     * <pre>
     * SQLState: 08003 - Client connection has been closed.
     * </pre>
     */
    CLIENT_CONNECTION_DOES_NOT_EXIST(77, 1103),
    /**
     * <code>CLIENT_UNABLE_TO_ESTABLISH_CONNECTION = 1102;</code>
     *
     * <pre>
     * SQLState: 08006 - Client connection failure
     * </pre>
     */
    CLIENT_UNABLE_TO_ESTABLISH_CONNECTION(78, 1102),
    /**
     * <code>CLIENT_PROTOCOL_PROTOCOL_VIOLATION = 1104;</code>
     *
     * <pre>
     * SQLState: 08P01 - Protocol violation
     * </pre>
     */
    CLIENT_PROTOCOL_PROTOCOL_VIOLATION(79, 1104),
    /**
     * <code>INSUFFICIENT_RESOURCE = 53000;</code>
     *
     * <pre>
     * 53 - Invalid Operand or Inconsistent Specification
     * </pre>
     */
    INSUFFICIENT_RESOURCE(80, 53000),
    /**
     * <code>DISK_FULL = 53100;</code>
     */
    DISK_FULL(81, 53100),
    /**
     * <code>OUT_OF_MEMORY = 53200;</code>
     */
    OUT_OF_MEMORY(82, 53200),
    /**
     * <code>PROGRAM_LIMIT_EXCEEDED = 54000;</code>
     *
     * <pre>
     * 54 - SQL or Product Limit Exceeded
     * </pre>
     */
    PROGRAM_LIMIT_EXCEEDED(83, 54000),
    /**
     * <code>STATEMENT_TOO_COMPLEX = 54001;</code>
     */
    STATEMENT_TOO_COMPLEX(84, 54001),
    /**
     * <code>STRING_CONSTANT_TOOL_LONG = 54002;</code>
     */
    STRING_CONSTANT_TOOL_LONG(85, 54002),
    /**
     * <code>TOO_LARGE_INPUT_FOR_CROSS_JOIN = 54003;</code>
     */
    TOO_LARGE_INPUT_FOR_CROSS_JOIN(86, 54003),
    /**
     * <code>INVALID_INPUTS_FOR_CROSS_JOIN = 54004;</code>
     */
    INVALID_INPUTS_FOR_CROSS_JOIN(87, 54004),
    /**
     * <code>TOO_MANY_TABLES = 54006;</code>
     */
    TOO_MANY_TABLES(88, 54006),
    /**
     * <code>TOO_MANY_COLUMNS = 54011;</code>
     */
    TOO_MANY_COLUMNS(89, 54011),
    /**
     * <code>TOO_MANY_ARGUMENTS = 54023;</code>
     */
    TOO_MANY_ARGUMENTS(90, 54023),
    /**
     * <code>IO_ERROR = 58030;</code>
     *
     * <pre>
     * 58 - System Error
     * </pre>
     */
    IO_ERROR(91, 58030),
    /**
     * <code>EPERM = 10001;</code>
     *
     * <pre>
     * underlying system errors based on errno.h.
     * </pre>
     */
    EPERM(92, 10001),
    /**
     * <code>ENOENT = 10002;</code>
     *
     * <pre>
     * No such file or directory
     * </pre>
     */
    ENOENT(93, 10002),
    /**
     * <code>ESRCH = 10003;</code>
     *
     * <pre>
     * No such process
     * </pre>
     */
    ESRCH(94, 10003),
    /**
     * <code>EINTR = 10004;</code>
     *
     * <pre>
     * Interrupted system call
     * </pre>
     */
    EINTR(95, 10004),
    /**
     * <code>EIO = 10005;</code>
     *
     * <pre>
     * I/O error
     * </pre>
     */
    EIO(96, 10005),
    /**
     * <code>ENXIO = 10006;</code>
     *
     * <pre>
     * No such device or address
     * </pre>
     */
    ENXIO(97, 10006),
    /**
     * <code>E2BIG = 10007;</code>
     *
     * <pre>
     * Argument list too long
     * </pre>
     */
    E2BIG(98, 10007),
    /**
     * <code>ENOEXEC = 10008;</code>
     *
     * <pre>
     * Exec format error
     * </pre>
     */
    ENOEXEC(99, 10008),
    /**
     * <code>EBADF = 10009;</code>
     *
     * <pre>
     * Bad file number
     * </pre>
     */
    EBADF(100, 10009),
    /**
     * <code>ECHILD = 10010;</code>
     *
     * <pre>
     * No child processes
     * </pre>
     */
    ECHILD(101, 10010),
    /**
     * <code>EAGAIN = 10011;</code>
     *
     * <pre>
     * Try again
     * </pre>
     */
    EAGAIN(102, 10011),
    /**
     * <code>ENOMEM = 10012;</code>
     *
     * <pre>
     * Out of memory
     * </pre>
     */
    ENOMEM(103, 10012),
    /**
     * <code>EACCES = 10013;</code>
     *
     * <pre>
     * Permission denied
     * </pre>
     */
    EACCES(104, 10013),
    /**
     * <code>EFAULT = 10014;</code>
     *
     * <pre>
     * Bad address
     * </pre>
     */
    EFAULT(105, 10014),
    /**
     * <code>ENOTBLK = 10015;</code>
     *
     * <pre>
     * Block device required
     * </pre>
     */
    ENOTBLK(106, 10015),
    /**
     * <code>EBUSY = 10016;</code>
     *
     * <pre>
     * Device or resource busy
     * </pre>
     */
    EBUSY(107, 10016),
    /**
     * <code>EEXIST = 10017;</code>
     *
     * <pre>
     * File exists
     * </pre>
     */
    EEXIST(108, 10017),
    /**
     * <code>EXDEV = 10018;</code>
     *
     * <pre>
     * Cross-device link
     * </pre>
     */
    EXDEV(109, 10018),
    /**
     * <code>ENODEV = 10019;</code>
     *
     * <pre>
     * No such device
     * </pre>
     */
    ENODEV(110, 10019),
    /**
     * <code>ENOTDIR = 10020;</code>
     *
     * <pre>
     * Not a directory
     * </pre>
     */
    ENOTDIR(111, 10020),
    /**
     * <code>EISDIR = 10021;</code>
     *
     * <pre>
     * Is a directory
     * </pre>
     */
    EISDIR(112, 10021),
    /**
     * <code>EINVAL = 10022;</code>
     *
     * <pre>
     * Invalid argument
     * </pre>
     */
    EINVAL(113, 10022),
    /**
     * <code>ENFILE = 10023;</code>
     *
     * <pre>
     * File table overflow
     * </pre>
     */
    ENFILE(114, 10023),
    /**
     * <code>EMFILE = 10024;</code>
     *
     * <pre>
     * Too many open files
     * </pre>
     */
    EMFILE(115, 10024),
    /**
     * <code>ENOTTY = 10025;</code>
     *
     * <pre>
     * Not a typewriter
     * </pre>
     */
    ENOTTY(116, 10025),
    /**
     * <code>ETXTBSY = 10026;</code>
     *
     * <pre>
     * Text file busy
     * </pre>
     */
    ETXTBSY(117, 10026),
    /**
     * <code>EFBIG = 10027;</code>
     *
     * <pre>
     * File too large
     * </pre>
     */
    EFBIG(118, 10027),
    /**
     * <code>ENOSPC = 10028;</code>
     *
     * <pre>
     * No space left on device
     * </pre>
     */
    ENOSPC(119, 10028),
    /**
     * <code>ESPIPE = 10029;</code>
     *
     * <pre>
     * Illegal seek
     * </pre>
     */
    ESPIPE(120, 10029),
    /**
     * <code>EROFS = 10030;</code>
     *
     * <pre>
     * Read-only file system
     * </pre>
     */
    EROFS(121, 10030),
    /**
     * <code>EMLINK = 10031;</code>
     *
     * <pre>
     * Too many links
     * </pre>
     */
    EMLINK(122, 10031),
    /**
     * <code>EPIPE = 10032;</code>
     *
     * <pre>
     * Broken pipe
     * </pre>
     */
    EPIPE(123, 10032),
    /**
     * <code>EDOM = 10033;</code>
     *
     * <pre>
     * Math argument out of domain of func
     * </pre>
     */
    EDOM(124, 10033),
    /**
     * <code>ERANGE = 10034;</code>
     *
     * <pre>
     * Math result not representable
     * </pre>
     */
    ERANGE(125, 10034),
    /**
     * <code>EDEADLK = 10035;</code>
     *
     * <pre>
     * Resource deadlock would occur
     * </pre>
     */
    EDEADLK(126, 10035),
    /**
     * <code>ENAMETOOLONG = 10036;</code>
     *
     * <pre>
     * File name too long
     * </pre>
     */
    ENAMETOOLONG(127, 10036),
    /**
     * <code>ENOLCK = 10037;</code>
     *
     * <pre>
     * No record locks available
     * </pre>
     */
    ENOLCK(128, 10037),
    /**
     * <code>ENOSYS = 10038;</code>
     *
     * <pre>
     * Function not implemented
     * </pre>
     */
    ENOSYS(129, 10038),
    /**
     * <code>ENOTEMPTY = 10039;</code>
     *
     * <pre>
     * Directory not empty
     * </pre>
     */
    ENOTEMPTY(130, 10039),
    /**
     * <code>ELOOP = 10040;</code>
     *
     * <pre>
     * Too many symbolic links encountered
     * </pre>
     */
    ELOOP(131, 10040),
    /**
     * <code>ENOMSG = 10042;</code>
     *
     * <pre>
     * EWOULDBLOCK                = EAGAIN  // Operation would block
     * </pre>
     */
    ENOMSG(132, 10042),
    /**
     * <code>EIDRM = 10043;</code>
     *
     * <pre>
     * Identifier removed
     * </pre>
     */
    EIDRM(133, 10043),
    /**
     * <code>ECHRNG = 10044;</code>
     *
     * <pre>
     * Channel number out of range
     * </pre>
     */
    ECHRNG(134, 10044),
    /**
     * <code>EL2NSYNC = 10045;</code>
     *
     * <pre>
     * Level 2 not synchronized
     * </pre>
     */
    EL2NSYNC(135, 10045),
    /**
     * <code>EL3HLT = 10046;</code>
     *
     * <pre>
     * Level 3 halted
     * </pre>
     */
    EL3HLT(136, 10046),
    /**
     * <code>EL3RST = 10047;</code>
     *
     * <pre>
     * Level 3 reset
     * </pre>
     */
    EL3RST(137, 10047),
    /**
     * <code>ELNRNG = 10048;</code>
     *
     * <pre>
     * Link number out of range
     * </pre>
     */
    ELNRNG(138, 10048),
    /**
     * <code>EUNATCH = 10049;</code>
     *
     * <pre>
     * Protocol driver not attached
     * </pre>
     */
    EUNATCH(139, 10049),
    /**
     * <code>ENOCSI = 10050;</code>
     *
     * <pre>
     * No CSI structure available
     * </pre>
     */
    ENOCSI(140, 10050),
    /**
     * <code>EL2HLT = 10051;</code>
     *
     * <pre>
     * Level 2 halted
     * </pre>
     */
    EL2HLT(141, 10051),
    /**
     * <code>EBADE = 10052;</code>
     *
     * <pre>
     * Invalid exchange
     * </pre>
     */
    EBADE(142, 10052),
    /**
     * <code>EBADR = 10053;</code>
     *
     * <pre>
     * Invalid request descriptor
     * </pre>
     */
    EBADR(143, 10053),
    /**
     * <code>EXFULL = 10054;</code>
     *
     * <pre>
     * Exchange full
     * </pre>
     */
    EXFULL(144, 10054),
    /**
     * <code>ENOANO = 10055;</code>
     *
     * <pre>
     * No anode
     * </pre>
     */
    ENOANO(145, 10055),
    /**
     * <code>EBADRQC = 10056;</code>
     *
     * <pre>
     * Invalid request code
     * </pre>
     */
    EBADRQC(146, 10056),
    /**
     * <code>EBADSLT = 10057;</code>
     *
     * <pre>
     * Invalid slot
     * </pre>
     */
    EBADSLT(147, 10057),
    /**
     * <code>EBFONT = 10059;</code>
     *
     * <pre>
     * EDEADLOCK                  = EDEADLK
     * </pre>
     */
    EBFONT(148, 10059),
    /**
     * <code>ENOSTR = 10060;</code>
     *
     * <pre>
     * Device not a stream
     * </pre>
     */
    ENOSTR(149, 10060),
    /**
     * <code>ENODATA = 10061;</code>
     *
     * <pre>
     * No data available
     * </pre>
     */
    ENODATA(150, 10061),
    /**
     * <code>ETIME = 10062;</code>
     *
     * <pre>
     * Timer expired
     * </pre>
     */
    ETIME(151, 10062),
    /**
     * <code>ENOSR = 10063;</code>
     *
     * <pre>
     * Out of streams resources
     * </pre>
     */
    ENOSR(152, 10063),
    /**
     * <code>ENONET = 10064;</code>
     *
     * <pre>
     * Machine is not on the network
     * </pre>
     */
    ENONET(153, 10064),
    /**
     * <code>ENOPKG = 10065;</code>
     *
     * <pre>
     * Package not installed
     * </pre>
     */
    ENOPKG(154, 10065),
    /**
     * <code>EREMOTE = 10066;</code>
     *
     * <pre>
     * Object is remote
     * </pre>
     */
    EREMOTE(155, 10066),
    /**
     * <code>ENOLINK = 10067;</code>
     *
     * <pre>
     * Link has been severed
     * </pre>
     */
    ENOLINK(156, 10067),
    /**
     * <code>EADV = 10068;</code>
     *
     * <pre>
     * Advertise error
     * </pre>
     */
    EADV(157, 10068),
    /**
     * <code>ESRMNT = 10069;</code>
     *
     * <pre>
     * Srmount error
     * </pre>
     */
    ESRMNT(158, 10069),
    /**
     * <code>ECOMM = 10070;</code>
     *
     * <pre>
     * Communication error on send
     * </pre>
     */
    ECOMM(159, 10070),
    /**
     * <code>EPROTO = 10071;</code>
     *
     * <pre>
     * Protocol error
     * </pre>
     */
    EPROTO(160, 10071),
    /**
     * <code>EMULTIHOP = 10072;</code>
     *
     * <pre>
     * Multihop attempted
     * </pre>
     */
    EMULTIHOP(161, 10072),
    /**
     * <code>EDOTDOT = 10073;</code>
     *
     * <pre>
     * RFS specific error
     * </pre>
     */
    EDOTDOT(162, 10073),
    /**
     * <code>EBADMSG = 10074;</code>
     *
     * <pre>
     * Not a data message
     * </pre>
     */
    EBADMSG(163, 10074),
    /**
     * <code>EOVERFLOW = 10075;</code>
     *
     * <pre>
     * Value too large for defined data type
     * </pre>
     */
    EOVERFLOW(164, 10075),
    /**
     * <code>ENOTUNIQ = 10076;</code>
     *
     * <pre>
     * Name not unique on network
     * </pre>
     */
    ENOTUNIQ(165, 10076),
    /**
     * <code>EBADFD = 10077;</code>
     *
     * <pre>
     * File descriptor in bad state
     * </pre>
     */
    EBADFD(166, 10077),
    /**
     * <code>EREMCHG = 10078;</code>
     *
     * <pre>
     * Remote address changed
     * </pre>
     */
    EREMCHG(167, 10078),
    /**
     * <code>ELIBACC = 10079;</code>
     *
     * <pre>
     * Can not access a needed shared library
     * </pre>
     */
    ELIBACC(168, 10079),
    /**
     * <code>ELIBBAD = 10080;</code>
     *
     * <pre>
     * Accessing a corrupted shared library
     * </pre>
     */
    ELIBBAD(169, 10080),
    /**
     * <code>ELIBSCN = 10081;</code>
     *
     * <pre>
     * .lib section in a.out corrupted
     * </pre>
     */
    ELIBSCN(170, 10081),
    /**
     * <code>ELIBMAX = 10082;</code>
     *
     * <pre>
     * Attempting to link in too many shared libraries
     * </pre>
     */
    ELIBMAX(171, 10082),
    /**
     * <code>ELIBEXEC = 10083;</code>
     *
     * <pre>
     * Cannot exec a shared library directly
     * </pre>
     */
    ELIBEXEC(172, 10083),
    /**
     * <code>EILSEQ = 10084;</code>
     *
     * <pre>
     * Illegal byte sequence
     * </pre>
     */
    EILSEQ(173, 10084),
    /**
     * <code>ERESTART = 10085;</code>
     *
     * <pre>
     * Interrupted system call should be restarted
     * </pre>
     */
    ERESTART(174, 10085),
    /**
     * <code>ESTRPIPE = 10086;</code>
     *
     * <pre>
     * Streams pipe error
     * </pre>
     */
    ESTRPIPE(175, 10086),
    /**
     * <code>EUSERS = 10087;</code>
     *
     * <pre>
     * Too many users
     * </pre>
     */
    EUSERS(176, 10087),
    /**
     * <code>ENOTSOCK = 10088;</code>
     *
     * <pre>
     * Socket operation on non-socket
     * </pre>
     */
    ENOTSOCK(177, 10088),
    /**
     * <code>EDESTADDRREQ = 10089;</code>
     *
     * <pre>
     * Destination address required
     * </pre>
     */
    EDESTADDRREQ(178, 10089),
    /**
     * <code>EMSGSIZE = 10090;</code>
     *
     * <pre>
     * Message too long
     * </pre>
     */
    EMSGSIZE(179, 10090),
    /**
     * <code>EPROTOTYPE = 10091;</code>
     *
     * <pre>
     * Protocol wrong type for socket
     * </pre>
     */
    EPROTOTYPE(180, 10091),
    /**
     * <code>ENOPROTOOPT = 10092;</code>
     *
     * <pre>
     * Protocol not available
     * </pre>
     */
    ENOPROTOOPT(181, 10092),
    /**
     * <code>EPROTONOSUPPORT = 10093;</code>
     *
     * <pre>
     * Protocol not supported
     * </pre>
     */
    EPROTONOSUPPORT(182, 10093),
    /**
     * <code>ESOCKTNOSUPPORT = 10094;</code>
     *
     * <pre>
     * Socket type not supported
     * </pre>
     */
    ESOCKTNOSUPPORT(183, 10094),
    /**
     * <code>EOPNOTSUPP = 10095;</code>
     *
     * <pre>
     * Operation not supported on transport endpoint
     * </pre>
     */
    EOPNOTSUPP(184, 10095),
    /**
     * <code>EPFNOSUPPORT = 10096;</code>
     *
     * <pre>
     * Protocol family not supported
     * </pre>
     */
    EPFNOSUPPORT(185, 10096),
    /**
     * <code>EAFNOSUPPORT = 10097;</code>
     *
     * <pre>
     * Address family not supported by protocol
     * </pre>
     */
    EAFNOSUPPORT(186, 10097),
    /**
     * <code>EADDRINUSE = 10098;</code>
     *
     * <pre>
     * Address already in use
     * </pre>
     */
    EADDRINUSE(187, 10098),
    /**
     * <code>EADDRNOTAVAIL = 10099;</code>
     *
     * <pre>
     * Cannot assign requested address
     * </pre>
     */
    EADDRNOTAVAIL(188, 10099),
    /**
     * <code>ENETDOWN = 10100;</code>
     *
     * <pre>
     * Network is down
     * </pre>
     */
    ENETDOWN(189, 10100),
    /**
     * <code>ENETUNREACH = 10101;</code>
     *
     * <pre>
     * Network is unreachable
     * </pre>
     */
    ENETUNREACH(190, 10101),
    /**
     * <code>ENETRESET = 10102;</code>
     *
     * <pre>
     * Network dropped connection because of reset
     * </pre>
     */
    ENETRESET(191, 10102),
    /**
     * <code>ECONNABORTED = 10103;</code>
     *
     * <pre>
     * Software caused connection abort
     * </pre>
     */
    ECONNABORTED(192, 10103),
    /**
     * <code>ECONNRESET = 10104;</code>
     *
     * <pre>
     * Connection reset by peer
     * </pre>
     */
    ECONNRESET(193, 10104),
    /**
     * <code>ENOBUFS = 10105;</code>
     *
     * <pre>
     * No buffer space available
     * </pre>
     */
    ENOBUFS(194, 10105),
    /**
     * <code>EISCONN = 10106;</code>
     *
     * <pre>
     * Transport endpoint is already connected
     * </pre>
     */
    EISCONN(195, 10106),
    /**
     * <code>ENOTCONN = 10107;</code>
     *
     * <pre>
     * Transport endpoint is not connected
     * </pre>
     */
    ENOTCONN(196, 10107),
    /**
     * <code>ESHUTDOWN = 10108;</code>
     *
     * <pre>
     * Cannot send after transport endpoint shutdown
     * </pre>
     */
    ESHUTDOWN(197, 10108),
    /**
     * <code>ETOOMANYREFS = 10109;</code>
     *
     * <pre>
     * Too many references: cannot splice
     * </pre>
     */
    ETOOMANYREFS(198, 10109),
    /**
     * <code>ETIMEDOUT = 10110;</code>
     *
     * <pre>
     * Connection timed out
     * </pre>
     */
    ETIMEDOUT(199, 10110),
    /**
     * <code>ECONNREFUSED = 10111;</code>
     *
     * <pre>
     * Connection refused
     * </pre>
     */
    ECONNREFUSED(200, 10111),
    /**
     * <code>EHOSTDOWN = 10112;</code>
     *
     * <pre>
     * Host is down
     * </pre>
     */
    EHOSTDOWN(201, 10112),
    /**
     * <code>EHOSTUNREACH = 10113;</code>
     *
     * <pre>
     * No route to host
     * </pre>
     */
    EHOSTUNREACH(202, 10113),
    /**
     * <code>EALREADY = 10114;</code>
     *
     * <pre>
     * Operation already in progress
     * </pre>
     */
    EALREADY(203, 10114),
    /**
     * <code>EINPROGRESS = 10115;</code>
     *
     * <pre>
     * Operation now in progress
     * </pre>
     */
    EINPROGRESS(204, 10115),
    /**
     * <code>ESTALE = 10116;</code>
     *
     * <pre>
     * Stale NFS file handle
     * </pre>
     */
    ESTALE(205, 10116),
    /**
     * <code>EUCLEAN = 10117;</code>
     *
     * <pre>
     * Structure needs cleaning
     * </pre>
     */
    EUCLEAN(206, 10117),
    /**
     * <code>ENOTNAM = 10118;</code>
     *
     * <pre>
     * Not a XENIX named type file
     * </pre>
     */
    ENOTNAM(207, 10118),
    /**
     * <code>ENAVAIL = 10119;</code>
     *
     * <pre>
     * No XENIX semaphores available
     * </pre>
     */
    ENAVAIL(208, 10119),
    /**
     * <code>EISNAM = 10120;</code>
     *
     * <pre>
     * Is a named type file
     * </pre>
     */
    EISNAM(209, 10120),
    /**
     * <code>EREMOTEIO = 10121;</code>
     *
     * <pre>
     * Remote I/O error
     * </pre>
     */
    EREMOTEIO(210, 10121),
    /**
     * <code>EDQUOT = 10122;</code>
     *
     * <pre>
     * Quota exceeded
     * </pre>
     */
    EDQUOT(211, 10122),
    /**
     * <code>ENOMEDIUM = 10123;</code>
     *
     * <pre>
     * No medium found
     * </pre>
     */
    ENOMEDIUM(212, 10123),
    /**
     * <code>EMEDIUMTYPE = 10124;</code>
     *
     * <pre>
     * Wrong medium type
     * </pre>
     */
    EMEDIUMTYPE(213, 10124),
    /**
     * <code>ECANCELED = 10125;</code>
     *
     * <pre>
     * Operation Canceled
     * </pre>
     */
    ECANCELED(214, 10125),
    /**
     * <code>ENOKEY = 10126;</code>
     *
     * <pre>
     * Required key not available
     * </pre>
     */
    ENOKEY(215, 10126),
    /**
     * <code>EKEYEXPIRED = 10127;</code>
     *
     * <pre>
     * Key has expired
     * </pre>
     */
    EKEYEXPIRED(216, 10127),
    /**
     * <code>EKEYREVOKED = 10128;</code>
     *
     * <pre>
     * Key has been revoked
     * </pre>
     */
    EKEYREVOKED(217, 10128),
    /**
     * <code>EKEYREJECTED = 10129;</code>
     *
     * <pre>
     * Key was rejected by service
     * </pre>
     */
    EKEYREJECTED(218, 10129),
    /**
     * <code>EOWNERDEAD = 10130;</code>
     *
     * <pre>
     * for robust mutexes
     * </pre>
     */
    EOWNERDEAD(219, 10130),
    /**
     * <code>ENOTRECOVERABLE = 10131;</code>
     *
     * <pre>
     * State not recoverable
     * </pre>
     */
    ENOTRECOVERABLE(220, 10131),
    ;

    /**
     * <code>OK = 0;</code>
     *
     * <pre>
     * Class
     * 00 - Successful Completion
     * </pre>
     */
    public static final int OK_VALUE = 0;
    /**
     * <code>WARNING = 100;</code>
     *
     * <pre>
     * Warning
     * </pre>
     */
    public static final int WARNING_VALUE = 100;
    /**
     * <code>INTERNAL_ERROR = 201;</code>
     *
     * <pre>
     * General Errors
     * </pre>
     */
    public static final int INTERNAL_ERROR_VALUE = 201;
    /**
     * <code>NOT_IMPLEMENTED = 202;</code>
     *
     * <pre>
     * SQLState: 0A000 - Not implemented yet, but planned.
     * </pre>
     */
    public static final int NOT_IMPLEMENTED_VALUE = 202;
    /**
     * <code>FEATURE_NOT_SUPPORTED = 203;</code>
     *
     * <pre>
     * SQLState: 0A000 - Unsupported feature (usually for unreasonable feature)
     * </pre>
     */
    public static final int FEATURE_NOT_SUPPORTED_VALUE = 203;
    /**
     * <code>INVALID_RPC_CALL = 204;</code>
     *
     * <pre>
     * SQLState: 08P01 - When invalid RPC call is invoked (e.g., wrong message and absent fields)
     * </pre>
     */
    public static final int INVALID_RPC_CALL_VALUE = 204;
    /**
     * <code>QUERY_FAILED = 301;</code>
     *
     * <pre>
     * Query Management and Scheduler
     * </pre>
     */
    public static final int QUERY_FAILED_VALUE = 301;
    /**
     * <code>QUERY_KILLED = 302;</code>
     *
     * <pre>
     * SQLState: 61T02 - Query killed
     * </pre>
     */
    public static final int QUERY_KILLED_VALUE = 302;
    /**
     * <code>QUERY_TIMEOUT = 303;</code>
     *
     * <pre>
     * SQLState: 61T03 - Timeout for the query
     * </pre>
     */
    public static final int QUERY_TIMEOUT_VALUE = 303;
    /**
     * <code>QUERY_NOT_FOUND = 304;</code>
     *
     * <pre>
     * SQLState: 61T04 - No such query in TajoMaster
     * </pre>
     */
    public static final int QUERY_NOT_FOUND_VALUE = 304;
    /**
     * <code>NO_DATA = 305;</code>
     *
     * <pre>
     * SQLState: 61T05 - No data due to query fail or error
     * </pre>
     */
    public static final int NO_DATA_VALUE = 305;
    /**
     * <code>INCOMPLETE_QUERY = 306;</code>
     *
     * <pre>
     * SQLState: 61T06 - It occurs when a client requests something of a completed query.
     * </pre>
     */
    public static final int INCOMPLETE_QUERY_VALUE = 306;
    /**
     * <code>INVALID_SESSION = 401;</code>
     *
     * <pre>
     * Session
     * </pre>
     */
    public static final int INVALID_SESSION_VALUE = 401;
    /**
     * <code>NO_SUCH_SESSION_VARIABLE = 402;</code>
     *
     * <pre>
     * SQLState: 62T01 - Session variable not found
     * </pre>
     */
    public static final int NO_SUCH_SESSION_VARIABLE_VALUE = 402;
    /**
     * <code>INVALID_SESSION_VARIABLE = 403;</code>
     *
     * <pre>
     * SQLState: 62T01 - Session variable is invalid (type mismatch or out of range)
     * </pre>
     */
    public static final int INVALID_SESSION_VARIABLE_VALUE = 403;
    /**
     * <code>DIVISION_BY_ZERO = 451;</code>
     *
     * <pre>
     * Data Exception (SQLState Class - 22)
     * </pre>
     */
    public static final int DIVISION_BY_ZERO_VALUE = 451;
    /**
     * <code>INVALID_VALUE_FOR_CAST = 452;</code>
     *
     * <pre>
     * SQLState: 22T01 - Invalid data value for cast
     * </pre>
     */
    public static final int INVALID_VALUE_FOR_CAST_VALUE = 452;
    /**
     * <code>INVALID_URL = 453;</code>
     *
     * <pre>
     * SQLState: 22T02 - Invalid URL
     * </pre>
     */
    public static final int INVALID_URL_VALUE = 453;
    /**
     * <code>SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION = 501;</code>
     *
     * <pre>
     * Section: Class 42 - Syntax Error or Access Rule Violation
     * </pre>
     */
    public static final int SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION_VALUE = 501;
    /**
     * <code>SYNTAX_ERROR = 502;</code>
     *
     * <pre>
     * SQLState: 42601
     * </pre>
     */
    public static final int SYNTAX_ERROR_VALUE = 502;
    /**
     * <code>INSUFFICIENT_PRIVILEGE = 503;</code>
     *
     * <pre>
     * SQLState: 42501
     * </pre>
     */
    public static final int INSUFFICIENT_PRIVILEGE_VALUE = 503;
    /**
     * <code>CANNOT_DROP_CURRENT_DATABASE = 504;</code>
     *
     * <pre>
     * SQLState: 42T01
     * </pre>
     */
    public static final int CANNOT_DROP_CURRENT_DATABASE_VALUE = 504;
    /**
     * <code>UNDEFINED_TABLESPACE = 511;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_TABLESPACE_VALUE = 511;
    /**
     * <code>UNDEFINED_DATABASE = 512;</code>
     *
     * <pre>
     * SQLState: 42T02
     * </pre>
     */
    public static final int UNDEFINED_DATABASE_VALUE = 512;
    /**
     * <code>UNDEFINED_SCHEMA = 513;</code>
     *
     * <pre>
     * SQLState:
     * </pre>
     */
    public static final int UNDEFINED_SCHEMA_VALUE = 513;
    /**
     * <code>UNDEFINED_TABLE = 514;</code>
     *
     * <pre>
     * SQLState: 42P01
     * </pre>
     */
    public static final int UNDEFINED_TABLE_VALUE = 514;
    /**
     * <code>UNDEFINED_COLUMN = 515;</code>
     *
     * <pre>
     * SQLState: 42703
     * </pre>
     */
    public static final int UNDEFINED_COLUMN_VALUE = 515;
    /**
     * <code>UNDEFINED_FUNCTION = 516;</code>
     *
     * <pre>
     * SQLState: 42883
     * </pre>
     */
    public static final int UNDEFINED_FUNCTION_VALUE = 516;
    /**
     * <code>UNDEFINED_INDEX_FOR_TABLE = 517;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_INDEX_FOR_TABLE_VALUE = 517;
    /**
     * <code>UNDEFINED_INDEX_FOR_COLUMNS = 518;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_INDEX_FOR_COLUMNS_VALUE = 518;
    /**
     * <code>UNDEFINED_INDEX_NAME = 519;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_INDEX_NAME_VALUE = 519;
    /**
     * <code>UNDEFINED_PARTITION = 520;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_PARTITION_VALUE = 520;
    /**
     * <code>UNDEFINED_PARTITION_METHOD = 521;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_PARTITION_METHOD_VALUE = 521;
    /**
     * <code>UNDEFINED_OPERATOR = 522;</code>
     *
     * <pre>
     * SQLState: 42883 (=UNDEFINED_FUNCTION)
     * </pre>
     */
    public static final int UNDEFINED_OPERATOR_VALUE = 522;
    /**
     * <code>UNDEFINED_PARTITION_KEY = 523;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_PARTITION_KEY_VALUE = 523;
    /**
     * <code>UNDEFINED_TABLESPACE_HANDLER = 524;</code>
     *
     * <pre>
     * SQLState: 42T11 - No Tablespace Handler for the URI scheme
     * </pre>
     */
    public static final int UNDEFINED_TABLESPACE_HANDLER_VALUE = 524;
    /**
     * <code>UNDEFINED_PARTITIONS = 525;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int UNDEFINED_PARTITIONS_VALUE = 525;
    /**
     * <code>DUPLICATE_TABLESPACE = 531;</code>
     */
    public static final int DUPLICATE_TABLESPACE_VALUE = 531;
    /**
     * <code>DUPLICATE_DATABASE = 532;</code>
     *
     * <pre>
     * SQLState: 42P04
     * </pre>
     */
    public static final int DUPLICATE_DATABASE_VALUE = 532;
    /**
     * <code>DUPLICATE_SCHEMA = 533;</code>
     *
     * <pre>
     * SQLState: 42P06
     * </pre>
     */
    public static final int DUPLICATE_SCHEMA_VALUE = 533;
    /**
     * <code>DUPLICATE_TABLE = 534;</code>
     *
     * <pre>
     * SQLState: 42P07
     * </pre>
     */
    public static final int DUPLICATE_TABLE_VALUE = 534;
    /**
     * <code>DUPLICATE_COLUMN = 535;</code>
     *
     * <pre>
     * SQLState: 42701
     * </pre>
     */
    public static final int DUPLICATE_COLUMN_VALUE = 535;
    /**
     * <code>DUPLICATE_ALIAS = 536;</code>
     *
     * <pre>
     * SQLState: 42712
     * </pre>
     */
    public static final int DUPLICATE_ALIAS_VALUE = 536;
    /**
     * <code>DUPLICATE_FUNCTION = 537;</code>
     *
     * <pre>
     * SQLState: 42723
     * </pre>
     */
    public static final int DUPLICATE_FUNCTION_VALUE = 537;
    /**
     * <code>DUPLICATE_INDEX = 538;</code>
     *
     * <pre>
     * SQLState: 42T07
     * </pre>
     */
    public static final int DUPLICATE_INDEX_VALUE = 538;
    /**
     * <code>DUPLICATE_PARTITION = 539;</code>
     *
     * <pre>
     * SQLState: 42T08
     * </pre>
     */
    public static final int DUPLICATE_PARTITION_VALUE = 539;
    /**
     * <code>AMBIGUOUS_TABLE = 541;</code>
     *
     * <pre>
     * SQLState: 42P09
     * </pre>
     */
    public static final int AMBIGUOUS_TABLE_VALUE = 541;
    /**
     * <code>AMBIGUOUS_COLUMN = 542;</code>
     *
     * <pre>
     * SQLState: 42702;
     * </pre>
     */
    public static final int AMBIGUOUS_COLUMN_VALUE = 542;
    /**
     * <code>AMBIGUOUS_FUNCTION = 543;</code>
     *
     * <pre>
     * SQLState: 42725;
     * </pre>
     */
    public static final int AMBIGUOUS_FUNCTION_VALUE = 543;
    /**
     * <code>AMBIGUOUS_PARTITION_DIRECTORY = 544;</code>
     *
     * <pre>
     * ?
     * </pre>
     */
    public static final int AMBIGUOUS_PARTITION_DIRECTORY_VALUE = 544;
    /**
     * <code>CANNOT_CAST = 601;</code>
     *
     * <pre>
     * SQLState: 42846 - Cast from source type to target type is not supported.
     * </pre>
     */
    public static final int CANNOT_CAST_VALUE = 601;
    /**
     * <code>GROUPING_ERROR = 602;</code>
     *
     * <pre>
     * SQLState: 42803
     * </pre>
     */
    public static final int GROUPING_ERROR_VALUE = 602;
    /**
     * <code>WINDOWING_ERROR = 603;</code>
     *
     * <pre>
     * SQLState: 42P20 - PgSQL implementation-defined
     * </pre>
     */
    public static final int WINDOWING_ERROR_VALUE = 603;
    /**
     * <code>INVALID_RECURSION = 604;</code>
     *
     * <pre>
     * SQLState: 42P19 - PgSQL implementation-defined
     * </pre>
     */
    public static final int INVALID_RECURSION_VALUE = 604;
    /**
     * <code>SET_OPERATION_SCHEMA_MISMATCH = 605;</code>
     *
     * <pre>
     * SQLState: 42601 (=SYNTAX_ERROR)
     * </pre>
     */
    public static final int SET_OPERATION_SCHEMA_MISMATCH_VALUE = 605;
    /**
     * <code>SET_OPERATION_DATATYPE_MISMATCH = 606;</code>
     *
     * <pre>
     * SQLState: 42601 (=SYNTAX_ERROR)
     * </pre>
     */
    public static final int SET_OPERATION_DATATYPE_MISMATCH_VALUE = 606;
    /**
     * <code>INVALID_FOREIGN_KEY = 621;</code>
     *
     * <pre>
     * SQLState: 42830
     * </pre>
     */
    public static final int INVALID_FOREIGN_KEY_VALUE = 621;
    /**
     * <code>INVALID_NAME = 622;</code>
     *
     * <pre>
     * SQLState: 42602
     * </pre>
     */
    public static final int INVALID_NAME_VALUE = 622;
    /**
     * <code>INVALID_COLUMN_DEFINITION = 623;</code>
     *
     * <pre>
     * SQLState: 42611
     * </pre>
     */
    public static final int INVALID_COLUMN_DEFINITION_VALUE = 623;
    /**
     * <code>NAME_TOO_LONG = 624;</code>
     *
     * <pre>
     * SQLState: 42622
     * </pre>
     */
    public static final int NAME_TOO_LONG_VALUE = 624;
    /**
     * <code>RESERVED_NAME = 625;</code>
     *
     * <pre>
     * SQLState: 42939
     * </pre>
     */
    public static final int RESERVED_NAME_VALUE = 625;
    /**
     * <code>DATATYPE_MISMATCH = 626;</code>
     *
     * <pre>
     * SQLState: 42804
     * </pre>
     */
    public static final int DATATYPE_MISMATCH_VALUE = 626;
    /**
     * <code>INDETERMINATE_DATATYPE = 627;</code>
     *
     * <pre>
     * SQLState: 42P18 - PgSQL implementation -defined
     * </pre>
     */
    public static final int INDETERMINATE_DATATYPE_VALUE = 627;
    /**
     * <code>INVALID_EXPRESSION = 701;</code>
     *
     * <pre>
     * Expressions
     * </pre>
     */
    public static final int INVALID_EXPRESSION_VALUE = 701;
    /**
     * <code>INVALID_DATATYPE = 703;</code>
     */
    public static final int INVALID_DATATYPE_VALUE = 703;
    /**
     * <code>NUMERIC_OVERFLOW = 803;</code>
     *
     * <pre>
     * Numeric value overflow
     * </pre>
     */
    public static final int NUMERIC_OVERFLOW_VALUE = 803;
    /**
     * <code>VALUE_LARGER_THAN_PRECISION = 804;</code>
     *
     * <pre>
     * Value larger than column precision
     * </pre>
     */
    public static final int VALUE_LARGER_THAN_PRECISION_VALUE = 804;
    /**
     * <code>CAT_UPGRADE_REQUIRED = 901;</code>
     *
     * <pre>
     * Meta Catalog
     * </pre>
     */
    public static final int CAT_UPGRADE_REQUIRED_VALUE = 901;
    /**
     * <code>CAT_CANNOT_CONNECT = 902;</code>
     *
     * <pre>
     * Cannot connect metadata server
     * </pre>
     */
    public static final int CAT_CANNOT_CONNECT_VALUE = 902;
    /**
     * <code>CAT_UNSUPPORTED_CATALOG_STORE = 905;</code>
     *
     * <pre>
     * Catalog store
     * </pre>
     */
    public static final int CAT_UNSUPPORTED_CATALOG_STORE_VALUE = 905;
    /**
     * <code>LMD_NO_MATCHED_DATATYPE = 910;</code>
     *
     * <pre>
     * Linked Metadata (LMD)
     * </pre>
     */
    public static final int LMD_NO_MATCHED_DATATYPE_VALUE = 910;
    /**
     * <code>UNAVAILABLE_TABLE_LOCATION = 1001;</code>
     *
     * <pre>
     * Storage and Data Format
     * </pre>
     */
    public static final int UNAVAILABLE_TABLE_LOCATION_VALUE = 1001;
    /**
     * <code>UNKNOWN_DATAFORMAT = 1002;</code>
     *
     * <pre>
     * SQLState: ? - Unknown Data Format
     * </pre>
     */
    public static final int UNKNOWN_DATAFORMAT_VALUE = 1002;
    /**
     * <code>UNSUPPORTED_DATATYPE = 1003;</code>
     *
     * <pre>
     * SQLState: ? - Unsupported data type
     * </pre>
     */
    public static final int UNSUPPORTED_DATATYPE_VALUE = 1003;
    /**
     * <code>INVALID_TABLE_PROPERTY = 1004;</code>
     *
     * <pre>
     * SQLState: ? - Invalid Table Property
     * </pre>
     */
    public static final int INVALID_TABLE_PROPERTY_VALUE = 1004;
    /**
     * <code>MISSING_TABLE_PROPERTY = 1005;</code>
     *
     * <pre>
     * SQLState: ? - Missing table property
     * </pre>
     */
    public static final int MISSING_TABLE_PROPERTY_VALUE = 1005;
    /**
     * <code>CLIENT_CONNECTION_EXCEPTION = 1101;</code>
     *
     * <pre>
     * Client Connection
     * </pre>
     */
    public static final int CLIENT_CONNECTION_EXCEPTION_VALUE = 1101;
    /**
     * <code>CLIENT_CONNECTION_DOES_NOT_EXIST = 1103;</code>
     *
     * <pre>
     * SQLState: 08003 - Client connection has been closed.
     * </pre>
     */
    public static final int CLIENT_CONNECTION_DOES_NOT_EXIST_VALUE = 1103;
    /**
     * <code>CLIENT_UNABLE_TO_ESTABLISH_CONNECTION = 1102;</code>
     *
     * <pre>
     * SQLState: 08006 - Client connection failure
     * </pre>
     */
    public static final int CLIENT_UNABLE_TO_ESTABLISH_CONNECTION_VALUE = 1102;
    /**
     * <code>CLIENT_PROTOCOL_PROTOCOL_VIOLATION = 1104;</code>
     *
     * <pre>
     * SQLState: 08P01 - Protocol violation
     * </pre>
     */
    public static final int CLIENT_PROTOCOL_PROTOCOL_VIOLATION_VALUE = 1104;
    /**
     * <code>INSUFFICIENT_RESOURCE = 53000;</code>
     *
     * <pre>
     * 53 - Invalid Operand or Inconsistent Specification
     * </pre>
     */
    public static final int INSUFFICIENT_RESOURCE_VALUE = 53000;
    /**
     * <code>DISK_FULL = 53100;</code>
     */
    public static final int DISK_FULL_VALUE = 53100;
    /**
     * <code>OUT_OF_MEMORY = 53200;</code>
     */
    public static final int OUT_OF_MEMORY_VALUE = 53200;
    /**
     * <code>PROGRAM_LIMIT_EXCEEDED = 54000;</code>
     *
     * <pre>
     * 54 - SQL or Product Limit Exceeded
     * </pre>
     */
    public static final int PROGRAM_LIMIT_EXCEEDED_VALUE = 54000;
    /**
     * <code>STATEMENT_TOO_COMPLEX = 54001;</code>
     */
    public static final int STATEMENT_TOO_COMPLEX_VALUE = 54001;
    /**
     * <code>STRING_CONSTANT_TOOL_LONG = 54002;</code>
     */
    public static final int STRING_CONSTANT_TOOL_LONG_VALUE = 54002;
    /**
     * <code>TOO_LARGE_INPUT_FOR_CROSS_JOIN = 54003;</code>
     */
    public static final int TOO_LARGE_INPUT_FOR_CROSS_JOIN_VALUE = 54003;
    /**
     * <code>INVALID_INPUTS_FOR_CROSS_JOIN = 54004;</code>
     */
    public static final int INVALID_INPUTS_FOR_CROSS_JOIN_VALUE = 54004;
    /**
     * <code>TOO_MANY_TABLES = 54006;</code>
     */
    public static final int TOO_MANY_TABLES_VALUE = 54006;
    /**
     * <code>TOO_MANY_COLUMNS = 54011;</code>
     */
    public static final int TOO_MANY_COLUMNS_VALUE = 54011;
    /**
     * <code>TOO_MANY_ARGUMENTS = 54023;</code>
     */
    public static final int TOO_MANY_ARGUMENTS_VALUE = 54023;
    /**
     * <code>IO_ERROR = 58030;</code>
     *
     * <pre>
     * 58 - System Error
     * </pre>
     */
    public static final int IO_ERROR_VALUE = 58030;
    /**
     * <code>EPERM = 10001;</code>
     *
     * <pre>
     * underlying system errors based on errno.h.
     * </pre>
     */
    public static final int EPERM_VALUE = 10001;
    /**
     * <code>ENOENT = 10002;</code>
     *
     * <pre>
     * No such file or directory
     * </pre>
     */
    public static final int ENOENT_VALUE = 10002;
    /**
     * <code>ESRCH = 10003;</code>
     *
     * <pre>
     * No such process
     * </pre>
     */
    public static final int ESRCH_VALUE = 10003;
    /**
     * <code>EINTR = 10004;</code>
     *
     * <pre>
     * Interrupted system call
     * </pre>
     */
    public static final int EINTR_VALUE = 10004;
    /**
     * <code>EIO = 10005;</code>
     *
     * <pre>
     * I/O error
     * </pre>
     */
    public static final int EIO_VALUE = 10005;
    /**
     * <code>ENXIO = 10006;</code>
     *
     * <pre>
     * No such device or address
     * </pre>
     */
    public static final int ENXIO_VALUE = 10006;
    /**
     * <code>E2BIG = 10007;</code>
     *
     * <pre>
     * Argument list too long
     * </pre>
     */
    public static final int E2BIG_VALUE = 10007;
    /**
     * <code>ENOEXEC = 10008;</code>
     *
     * <pre>
     * Exec format error
     * </pre>
     */
    public static final int ENOEXEC_VALUE = 10008;
    /**
     * <code>EBADF = 10009;</code>
     *
     * <pre>
     * Bad file number
     * </pre>
     */
    public static final int EBADF_VALUE = 10009;
    /**
     * <code>ECHILD = 10010;</code>
     *
     * <pre>
     * No child processes
     * </pre>
     */
    public static final int ECHILD_VALUE = 10010;
    /**
     * <code>EAGAIN = 10011;</code>
     *
     * <pre>
     * Try again
     * </pre>
     */
    public static final int EAGAIN_VALUE = 10011;
    /**
     * <code>ENOMEM = 10012;</code>
     *
     * <pre>
     * Out of memory
     * </pre>
     */
    public static final int ENOMEM_VALUE = 10012;
    /**
     * <code>EACCES = 10013;</code>
     *
     * <pre>
     * Permission denied
     * </pre>
     */
    public static final int EACCES_VALUE = 10013;
    /**
     * <code>EFAULT = 10014;</code>
     *
     * <pre>
     * Bad address
     * </pre>
     */
    public static final int EFAULT_VALUE = 10014;
    /**
     * <code>ENOTBLK = 10015;</code>
     *
     * <pre>
     * Block device required
     * </pre>
     */
    public static final int ENOTBLK_VALUE = 10015;
    /**
     * <code>EBUSY = 10016;</code>
     *
     * <pre>
     * Device or resource busy
     * </pre>
     */
    public static final int EBUSY_VALUE = 10016;
    /**
     * <code>EEXIST = 10017;</code>
     *
     * <pre>
     * File exists
     * </pre>
     */
    public static final int EEXIST_VALUE = 10017;
    /**
     * <code>EXDEV = 10018;</code>
     *
     * <pre>
     * Cross-device link
     * </pre>
     */
    public static final int EXDEV_VALUE = 10018;
    /**
     * <code>ENODEV = 10019;</code>
     *
     * <pre>
     * No such device
     * </pre>
     */
    public static final int ENODEV_VALUE = 10019;
    /**
     * <code>ENOTDIR = 10020;</code>
     *
     * <pre>
     * Not a directory
     * </pre>
     */
    public static final int ENOTDIR_VALUE = 10020;
    /**
     * <code>EISDIR = 10021;</code>
     *
     * <pre>
     * Is a directory
     * </pre>
     */
    public static final int EISDIR_VALUE = 10021;
    /**
     * <code>EINVAL = 10022;</code>
     *
     * <pre>
     * Invalid argument
     * </pre>
     */
    public static final int EINVAL_VALUE = 10022;
    /**
     * <code>ENFILE = 10023;</code>
     *
     * <pre>
     * File table overflow
     * </pre>
     */
    public static final int ENFILE_VALUE = 10023;
    /**
     * <code>EMFILE = 10024;</code>
     *
     * <pre>
     * Too many open files
     * </pre>
     */
    public static final int EMFILE_VALUE = 10024;
    /**
     * <code>ENOTTY = 10025;</code>
     *
     * <pre>
     * Not a typewriter
     * </pre>
     */
    public static final int ENOTTY_VALUE = 10025;
    /**
     * <code>ETXTBSY = 10026;</code>
     *
     * <pre>
     * Text file busy
     * </pre>
     */
    public static final int ETXTBSY_VALUE = 10026;
    /**
     * <code>EFBIG = 10027;</code>
     *
     * <pre>
     * File too large
     * </pre>
     */
    public static final int EFBIG_VALUE = 10027;
    /**
     * <code>ENOSPC = 10028;</code>
     *
     * <pre>
     * No space left on device
     * </pre>
     */
    public static final int ENOSPC_VALUE = 10028;
    /**
     * <code>ESPIPE = 10029;</code>
     *
     * <pre>
     * Illegal seek
     * </pre>
     */
    public static final int ESPIPE_VALUE = 10029;
    /**
     * <code>EROFS = 10030;</code>
     *
     * <pre>
     * Read-only file system
     * </pre>
     */
    public static final int EROFS_VALUE = 10030;
    /**
     * <code>EMLINK = 10031;</code>
     *
     * <pre>
     * Too many links
     * </pre>
     */
    public static final int EMLINK_VALUE = 10031;
    /**
     * <code>EPIPE = 10032;</code>
     *
     * <pre>
     * Broken pipe
     * </pre>
     */
    public static final int EPIPE_VALUE = 10032;
    /**
     * <code>EDOM = 10033;</code>
     *
     * <pre>
     * Math argument out of domain of func
     * </pre>
     */
    public static final int EDOM_VALUE = 10033;
    /**
     * <code>ERANGE = 10034;</code>
     *
     * <pre>
     * Math result not representable
     * </pre>
     */
    public static final int ERANGE_VALUE = 10034;
    /**
     * <code>EDEADLK = 10035;</code>
     *
     * <pre>
     * Resource deadlock would occur
     * </pre>
     */
    public static final int EDEADLK_VALUE = 10035;
    /**
     * <code>ENAMETOOLONG = 10036;</code>
     *
     * <pre>
     * File name too long
     * </pre>
     */
    public static final int ENAMETOOLONG_VALUE = 10036;
    /**
     * <code>ENOLCK = 10037;</code>
     *
     * <pre>
     * No record locks available
     * </pre>
     */
    public static final int ENOLCK_VALUE = 10037;
    /**
     * <code>ENOSYS = 10038;</code>
     *
     * <pre>
     * Function not implemented
     * </pre>
     */
    public static final int ENOSYS_VALUE = 10038;
    /**
     * <code>ENOTEMPTY = 10039;</code>
     *
     * <pre>
     * Directory not empty
     * </pre>
     */
    public static final int ENOTEMPTY_VALUE = 10039;
    /**
     * <code>ELOOP = 10040;</code>
     *
     * <pre>
     * Too many symbolic links encountered
     * </pre>
     */
    public static final int ELOOP_VALUE = 10040;
    /**
     * <code>ENOMSG = 10042;</code>
     *
     * <pre>
     * EWOULDBLOCK                = EAGAIN  // Operation would block
     * </pre>
     */
    public static final int ENOMSG_VALUE = 10042;
    /**
     * <code>EIDRM = 10043;</code>
     *
     * <pre>
     * Identifier removed
     * </pre>
     */
    public static final int EIDRM_VALUE = 10043;
    /**
     * <code>ECHRNG = 10044;</code>
     *
     * <pre>
     * Channel number out of range
     * </pre>
     */
    public static final int ECHRNG_VALUE = 10044;
    /**
     * <code>EL2NSYNC = 10045;</code>
     *
     * <pre>
     * Level 2 not synchronized
     * </pre>
     */
    public static final int EL2NSYNC_VALUE = 10045;
    /**
     * <code>EL3HLT = 10046;</code>
     *
     * <pre>
     * Level 3 halted
     * </pre>
     */
    public static final int EL3HLT_VALUE = 10046;
    /**
     * <code>EL3RST = 10047;</code>
     *
     * <pre>
     * Level 3 reset
     * </pre>
     */
    public static final int EL3RST_VALUE = 10047;
    /**
     * <code>ELNRNG = 10048;</code>
     *
     * <pre>
     * Link number out of range
     * </pre>
     */
    public static final int ELNRNG_VALUE = 10048;
    /**
     * <code>EUNATCH = 10049;</code>
     *
     * <pre>
     * Protocol driver not attached
     * </pre>
     */
    public static final int EUNATCH_VALUE = 10049;
    /**
     * <code>ENOCSI = 10050;</code>
     *
     * <pre>
     * No CSI structure available
     * </pre>
     */
    public static final int ENOCSI_VALUE = 10050;
    /**
     * <code>EL2HLT = 10051;</code>
     *
     * <pre>
     * Level 2 halted
     * </pre>
     */
    public static final int EL2HLT_VALUE = 10051;
    /**
     * <code>EBADE = 10052;</code>
     *
     * <pre>
     * Invalid exchange
     * </pre>
     */
    public static final int EBADE_VALUE = 10052;
    /**
     * <code>EBADR = 10053;</code>
     *
     * <pre>
     * Invalid request descriptor
     * </pre>
     */
    public static final int EBADR_VALUE = 10053;
    /**
     * <code>EXFULL = 10054;</code>
     *
     * <pre>
     * Exchange full
     * </pre>
     */
    public static final int EXFULL_VALUE = 10054;
    /**
     * <code>ENOANO = 10055;</code>
     *
     * <pre>
     * No anode
     * </pre>
     */
    public static final int ENOANO_VALUE = 10055;
    /**
     * <code>EBADRQC = 10056;</code>
     *
     * <pre>
     * Invalid request code
     * </pre>
     */
    public static final int EBADRQC_VALUE = 10056;
    /**
     * <code>EBADSLT = 10057;</code>
     *
     * <pre>
     * Invalid slot
     * </pre>
     */
    public static final int EBADSLT_VALUE = 10057;
    /**
     * <code>EBFONT = 10059;</code>
     *
     * <pre>
     * EDEADLOCK                  = EDEADLK
     * </pre>
     */
    public static final int EBFONT_VALUE = 10059;
    /**
     * <code>ENOSTR = 10060;</code>
     *
     * <pre>
     * Device not a stream
     * </pre>
     */
    public static final int ENOSTR_VALUE = 10060;
    /**
     * <code>ENODATA = 10061;</code>
     *
     * <pre>
     * No data available
     * </pre>
     */
    public static final int ENODATA_VALUE = 10061;
    /**
     * <code>ETIME = 10062;</code>
     *
     * <pre>
     * Timer expired
     * </pre>
     */
    public static final int ETIME_VALUE = 10062;
    /**
     * <code>ENOSR = 10063;</code>
     *
     * <pre>
     * Out of streams resources
     * </pre>
     */
    public static final int ENOSR_VALUE = 10063;
    /**
     * <code>ENONET = 10064;</code>
     *
     * <pre>
     * Machine is not on the network
     * </pre>
     */
    public static final int ENONET_VALUE = 10064;
    /**
     * <code>ENOPKG = 10065;</code>
     *
     * <pre>
     * Package not installed
     * </pre>
     */
    public static final int ENOPKG_VALUE = 10065;
    /**
     * <code>EREMOTE = 10066;</code>
     *
     * <pre>
     * Object is remote
     * </pre>
     */
    public static final int EREMOTE_VALUE = 10066;
    /**
     * <code>ENOLINK = 10067;</code>
     *
     * <pre>
     * Link has been severed
     * </pre>
     */
    public static final int ENOLINK_VALUE = 10067;
    /**
     * <code>EADV = 10068;</code>
     *
     * <pre>
     * Advertise error
     * </pre>
     */
    public static final int EADV_VALUE = 10068;
    /**
     * <code>ESRMNT = 10069;</code>
     *
     * <pre>
     * Srmount error
     * </pre>
     */
    public static final int ESRMNT_VALUE = 10069;
    /**
     * <code>ECOMM = 10070;</code>
     *
     * <pre>
     * Communication error on send
     * </pre>
     */
    public static final int ECOMM_VALUE = 10070;
    /**
     * <code>EPROTO = 10071;</code>
     *
     * <pre>
     * Protocol error
     * </pre>
     */
    public static final int EPROTO_VALUE = 10071;
    /**
     * <code>EMULTIHOP = 10072;</code>
     *
     * <pre>
     * Multihop attempted
     * </pre>
     */
    public static final int EMULTIHOP_VALUE = 10072;
    /**
     * <code>EDOTDOT = 10073;</code>
     *
     * <pre>
     * RFS specific error
     * </pre>
     */
    public static final int EDOTDOT_VALUE = 10073;
    /**
     * <code>EBADMSG = 10074;</code>
     *
     * <pre>
     * Not a data message
     * </pre>
     */
    public static final int EBADMSG_VALUE = 10074;
    /**
     * <code>EOVERFLOW = 10075;</code>
     *
     * <pre>
     * Value too large for defined data type
     * </pre>
     */
    public static final int EOVERFLOW_VALUE = 10075;
    /**
     * <code>ENOTUNIQ = 10076;</code>
     *
     * <pre>
     * Name not unique on network
     * </pre>
     */
    public static final int ENOTUNIQ_VALUE = 10076;
    /**
     * <code>EBADFD = 10077;</code>
     *
     * <pre>
     * File descriptor in bad state
     * </pre>
     */
    public static final int EBADFD_VALUE = 10077;
    /**
     * <code>EREMCHG = 10078;</code>
     *
     * <pre>
     * Remote address changed
     * </pre>
     */
    public static final int EREMCHG_VALUE = 10078;
    /**
     * <code>ELIBACC = 10079;</code>
     *
     * <pre>
     * Can not access a needed shared library
     * </pre>
     */
    public static final int ELIBACC_VALUE = 10079;
    /**
     * <code>ELIBBAD = 10080;</code>
     *
     * <pre>
     * Accessing a corrupted shared library
     * </pre>
     */
    public static final int ELIBBAD_VALUE = 10080;
    /**
     * <code>ELIBSCN = 10081;</code>
     *
     * <pre>
     * .lib section in a.out corrupted
     * </pre>
     */
    public static final int ELIBSCN_VALUE = 10081;
    /**
     * <code>ELIBMAX = 10082;</code>
     *
     * <pre>
     * Attempting to link in too many shared libraries
     * </pre>
     */
    public static final int ELIBMAX_VALUE = 10082;
    /**
     * <code>ELIBEXEC = 10083;</code>
     *
     * <pre>
     * Cannot exec a shared library directly
     * </pre>
     */
    public static final int ELIBEXEC_VALUE = 10083;
    /**
     * <code>EILSEQ = 10084;</code>
     *
     * <pre>
     * Illegal byte sequence
     * </pre>
     */
    public static final int EILSEQ_VALUE = 10084;
    /**
     * <code>ERESTART = 10085;</code>
     *
     * <pre>
     * Interrupted system call should be restarted
     * </pre>
     */
    public static final int ERESTART_VALUE = 10085;
    /**
     * <code>ESTRPIPE = 10086;</code>
     *
     * <pre>
     * Streams pipe error
     * </pre>
     */
    public static final int ESTRPIPE_VALUE = 10086;
    /**
     * <code>EUSERS = 10087;</code>
     *
     * <pre>
     * Too many users
     * </pre>
     */
    public static final int EUSERS_VALUE = 10087;
    /**
     * <code>ENOTSOCK = 10088;</code>
     *
     * <pre>
     * Socket operation on non-socket
     * </pre>
     */
    public static final int ENOTSOCK_VALUE = 10088;
    /**
     * <code>EDESTADDRREQ = 10089;</code>
     *
     * <pre>
     * Destination address required
     * </pre>
     */
    public static final int EDESTADDRREQ_VALUE = 10089;
    /**
     * <code>EMSGSIZE = 10090;</code>
     *
     * <pre>
     * Message too long
     * </pre>
     */
    public static final int EMSGSIZE_VALUE = 10090;
    /**
     * <code>EPROTOTYPE = 10091;</code>
     *
     * <pre>
     * Protocol wrong type for socket
     * </pre>
     */
    public static final int EPROTOTYPE_VALUE = 10091;
    /**
     * <code>ENOPROTOOPT = 10092;</code>
     *
     * <pre>
     * Protocol not available
     * </pre>
     */
    public static final int ENOPROTOOPT_VALUE = 10092;
    /**
     * <code>EPROTONOSUPPORT = 10093;</code>
     *
     * <pre>
     * Protocol not supported
     * </pre>
     */
    public static final int EPROTONOSUPPORT_VALUE = 10093;
    /**
     * <code>ESOCKTNOSUPPORT = 10094;</code>
     *
     * <pre>
     * Socket type not supported
     * </pre>
     */
    public static final int ESOCKTNOSUPPORT_VALUE = 10094;
    /**
     * <code>EOPNOTSUPP = 10095;</code>
     *
     * <pre>
     * Operation not supported on transport endpoint
     * </pre>
     */
    public static final int EOPNOTSUPP_VALUE = 10095;
    /**
     * <code>EPFNOSUPPORT = 10096;</code>
     *
     * <pre>
     * Protocol family not supported
     * </pre>
     */
    public static final int EPFNOSUPPORT_VALUE = 10096;
    /**
     * <code>EAFNOSUPPORT = 10097;</code>
     *
     * <pre>
     * Address family not supported by protocol
     * </pre>
     */
    public static final int EAFNOSUPPORT_VALUE = 10097;
    /**
     * <code>EADDRINUSE = 10098;</code>
     *
     * <pre>
     * Address already in use
     * </pre>
     */
    public static final int EADDRINUSE_VALUE = 10098;
    /**
     * <code>EADDRNOTAVAIL = 10099;</code>
     *
     * <pre>
     * Cannot assign requested address
     * </pre>
     */
    public static final int EADDRNOTAVAIL_VALUE = 10099;
    /**
     * <code>ENETDOWN = 10100;</code>
     *
     * <pre>
     * Network is down
     * </pre>
     */
    public static final int ENETDOWN_VALUE = 10100;
    /**
     * <code>ENETUNREACH = 10101;</code>
     *
     * <pre>
     * Network is unreachable
     * </pre>
     */
    public static final int ENETUNREACH_VALUE = 10101;
    /**
     * <code>ENETRESET = 10102;</code>
     *
     * <pre>
     * Network dropped connection because of reset
     * </pre>
     */
    public static final int ENETRESET_VALUE = 10102;
    /**
     * <code>ECONNABORTED = 10103;</code>
     *
     * <pre>
     * Software caused connection abort
     * </pre>
     */
    public static final int ECONNABORTED_VALUE = 10103;
    /**
     * <code>ECONNRESET = 10104;</code>
     *
     * <pre>
     * Connection reset by peer
     * </pre>
     */
    public static final int ECONNRESET_VALUE = 10104;
    /**
     * <code>ENOBUFS = 10105;</code>
     *
     * <pre>
     * No buffer space available
     * </pre>
     */
    public static final int ENOBUFS_VALUE = 10105;
    /**
     * <code>EISCONN = 10106;</code>
     *
     * <pre>
     * Transport endpoint is already connected
     * </pre>
     */
    public static final int EISCONN_VALUE = 10106;
    /**
     * <code>ENOTCONN = 10107;</code>
     *
     * <pre>
     * Transport endpoint is not connected
     * </pre>
     */
    public static final int ENOTCONN_VALUE = 10107;
    /**
     * <code>ESHUTDOWN = 10108;</code>
     *
     * <pre>
     * Cannot send after transport endpoint shutdown
     * </pre>
     */
    public static final int ESHUTDOWN_VALUE = 10108;
    /**
     * <code>ETOOMANYREFS = 10109;</code>
     *
     * <pre>
     * Too many references: cannot splice
     * </pre>
     */
    public static final int ETOOMANYREFS_VALUE = 10109;
    /**
     * <code>ETIMEDOUT = 10110;</code>
     *
     * <pre>
     * Connection timed out
     * </pre>
     */
    public static final int ETIMEDOUT_VALUE = 10110;
    /**
     * <code>ECONNREFUSED = 10111;</code>
     *
     * <pre>
     * Connection refused
     * </pre>
     */
    public static final int ECONNREFUSED_VALUE = 10111;
    /**
     * <code>EHOSTDOWN = 10112;</code>
     *
     * <pre>
     * Host is down
     * </pre>
     */
    public static final int EHOSTDOWN_VALUE = 10112;
    /**
     * <code>EHOSTUNREACH = 10113;</code>
     *
     * <pre>
     * No route to host
     * </pre>
     */
    public static final int EHOSTUNREACH_VALUE = 10113;
    /**
     * <code>EALREADY = 10114;</code>
     *
     * <pre>
     * Operation already in progress
     * </pre>
     */
    public static final int EALREADY_VALUE = 10114;
    /**
     * <code>EINPROGRESS = 10115;</code>
     *
     * <pre>
     * Operation now in progress
     * </pre>
     */
    public static final int EINPROGRESS_VALUE = 10115;
    /**
     * <code>ESTALE = 10116;</code>
     *
     * <pre>
     * Stale NFS file handle
     * </pre>
     */
    public static final int ESTALE_VALUE = 10116;
    /**
     * <code>EUCLEAN = 10117;</code>
     *
     * <pre>
     * Structure needs cleaning
     * </pre>
     */
    public static final int EUCLEAN_VALUE = 10117;
    /**
     * <code>ENOTNAM = 10118;</code>
     *
     * <pre>
     * Not a XENIX named type file
     * </pre>
     */
    public static final int ENOTNAM_VALUE = 10118;
    /**
     * <code>ENAVAIL = 10119;</code>
     *
     * <pre>
     * No XENIX semaphores available
     * </pre>
     */
    public static final int ENAVAIL_VALUE = 10119;
    /**
     * <code>EISNAM = 10120;</code>
     *
     * <pre>
     * Is a named type file
     * </pre>
     */
    public static final int EISNAM_VALUE = 10120;
    /**
     * <code>EREMOTEIO = 10121;</code>
     *
     * <pre>
     * Remote I/O error
     * </pre>
     */
    public static final int EREMOTEIO_VALUE = 10121;
    /**
     * <code>EDQUOT = 10122;</code>
     *
     * <pre>
     * Quota exceeded
     * </pre>
     */
    public static final int EDQUOT_VALUE = 10122;
    /**
     * <code>ENOMEDIUM = 10123;</code>
     *
     * <pre>
     * No medium found
     * </pre>
     */
    public static final int ENOMEDIUM_VALUE = 10123;
    /**
     * <code>EMEDIUMTYPE = 10124;</code>
     *
     * <pre>
     * Wrong medium type
     * </pre>
     */
    public static final int EMEDIUMTYPE_VALUE = 10124;
    /**
     * <code>ECANCELED = 10125;</code>
     *
     * <pre>
     * Operation Canceled
     * </pre>
     */
    public static final int ECANCELED_VALUE = 10125;
    /**
     * <code>ENOKEY = 10126;</code>
     *
     * <pre>
     * Required key not available
     * </pre>
     */
    public static final int ENOKEY_VALUE = 10126;
    /**
     * <code>EKEYEXPIRED = 10127;</code>
     *
     * <pre>
     * Key has expired
     * </pre>
     */
    public static final int EKEYEXPIRED_VALUE = 10127;
    /**
     * <code>EKEYREVOKED = 10128;</code>
     *
     * <pre>
     * Key has been revoked
     * </pre>
     */
    public static final int EKEYREVOKED_VALUE = 10128;
    /**
     * <code>EKEYREJECTED = 10129;</code>
     *
     * <pre>
     * Key was rejected by service
     * </pre>
     */
    public static final int EKEYREJECTED_VALUE = 10129;
    /**
     * <code>EOWNERDEAD = 10130;</code>
     *
     * <pre>
     * for robust mutexes
     * </pre>
     */
    public static final int EOWNERDEAD_VALUE = 10130;
    /**
     * <code>ENOTRECOVERABLE = 10131;</code>
     *
     * <pre>
     * State not recoverable
     * </pre>
     */
    public static final int ENOTRECOVERABLE_VALUE = 10131;


    public final int getNumber() { return value; }

    public static ResultCode valueOf(int value) {
      switch (value) {
        case 0: return OK;
        case 100: return WARNING;
        case 201: return INTERNAL_ERROR;
        case 202: return NOT_IMPLEMENTED;
        case 203: return FEATURE_NOT_SUPPORTED;
        case 204: return INVALID_RPC_CALL;
        case 301: return QUERY_FAILED;
        case 302: return QUERY_KILLED;
        case 303: return QUERY_TIMEOUT;
        case 304: return QUERY_NOT_FOUND;
        case 305: return NO_DATA;
        case 306: return INCOMPLETE_QUERY;
        case 401: return INVALID_SESSION;
        case 402: return NO_SUCH_SESSION_VARIABLE;
        case 403: return INVALID_SESSION_VARIABLE;
        case 451: return DIVISION_BY_ZERO;
        case 452: return INVALID_VALUE_FOR_CAST;
        case 453: return INVALID_URL;
        case 501: return SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION;
        case 502: return SYNTAX_ERROR;
        case 503: return INSUFFICIENT_PRIVILEGE;
        case 504: return CANNOT_DROP_CURRENT_DATABASE;
        case 511: return UNDEFINED_TABLESPACE;
        case 512: return UNDEFINED_DATABASE;
        case 513: return UNDEFINED_SCHEMA;
        case 514: return UNDEFINED_TABLE;
        case 515: return UNDEFINED_COLUMN;
        case 516: return UNDEFINED_FUNCTION;
        case 517: return UNDEFINED_INDEX_FOR_TABLE;
        case 518: return UNDEFINED_INDEX_FOR_COLUMNS;
        case 519: return UNDEFINED_INDEX_NAME;
        case 520: return UNDEFINED_PARTITION;
        case 521: return UNDEFINED_PARTITION_METHOD;
        case 522: return UNDEFINED_OPERATOR;
        case 523: return UNDEFINED_PARTITION_KEY;
        case 524: return UNDEFINED_TABLESPACE_HANDLER;
        case 525: return UNDEFINED_PARTITIONS;
        case 531: return DUPLICATE_TABLESPACE;
        case 532: return DUPLICATE_DATABASE;
        case 533: return DUPLICATE_SCHEMA;
        case 534: return DUPLICATE_TABLE;
        case 535: return DUPLICATE_COLUMN;
        case 536: return DUPLICATE_ALIAS;
        case 537: return DUPLICATE_FUNCTION;
        case 538: return DUPLICATE_INDEX;
        case 539: return DUPLICATE_PARTITION;
        case 541: return AMBIGUOUS_TABLE;
        case 542: return AMBIGUOUS_COLUMN;
        case 543: return AMBIGUOUS_FUNCTION;
        case 544: return AMBIGUOUS_PARTITION_DIRECTORY;
        case 601: return CANNOT_CAST;
        case 602: return GROUPING_ERROR;
        case 603: return WINDOWING_ERROR;
        case 604: return INVALID_RECURSION;
        case 605: return SET_OPERATION_SCHEMA_MISMATCH;
        case 606: return SET_OPERATION_DATATYPE_MISMATCH;
        case 621: return INVALID_FOREIGN_KEY;
        case 622: return INVALID_NAME;
        case 623: return INVALID_COLUMN_DEFINITION;
        case 624: return NAME_TOO_LONG;
        case 625: return RESERVED_NAME;
        case 626: return DATATYPE_MISMATCH;
        case 627: return INDETERMINATE_DATATYPE;
        case 701: return INVALID_EXPRESSION;
        case 703: return INVALID_DATATYPE;
        case 803: return NUMERIC_OVERFLOW;
        case 804: return VALUE_LARGER_THAN_PRECISION;
        case 901: return CAT_UPGRADE_REQUIRED;
        case 902: return CAT_CANNOT_CONNECT;
        case 905: return CAT_UNSUPPORTED_CATALOG_STORE;
        case 910: return LMD_NO_MATCHED_DATATYPE;
        case 1001: return UNAVAILABLE_TABLE_LOCATION;
        case 1002: return UNKNOWN_DATAFORMAT;
        case 1003: return UNSUPPORTED_DATATYPE;
        case 1004: return INVALID_TABLE_PROPERTY;
        case 1005: return MISSING_TABLE_PROPERTY;
        case 1101: return CLIENT_CONNECTION_EXCEPTION;
        case 1103: return CLIENT_CONNECTION_DOES_NOT_EXIST;
        case 1102: return CLIENT_UNABLE_TO_ESTABLISH_CONNECTION;
        case 1104: return CLIENT_PROTOCOL_PROTOCOL_VIOLATION;
        case 53000: return INSUFFICIENT_RESOURCE;
        case 53100: return DISK_FULL;
        case 53200: return OUT_OF_MEMORY;
        case 54000: return PROGRAM_LIMIT_EXCEEDED;
        case 54001: return STATEMENT_TOO_COMPLEX;
        case 54002: return STRING_CONSTANT_TOOL_LONG;
        case 54003: return TOO_LARGE_INPUT_FOR_CROSS_JOIN;
        case 54004: return INVALID_INPUTS_FOR_CROSS_JOIN;
        case 54006: return TOO_MANY_TABLES;
        case 54011: return TOO_MANY_COLUMNS;
        case 54023: return TOO_MANY_ARGUMENTS;
        case 58030: return IO_ERROR;
        case 10001: return EPERM;
        case 10002: return ENOENT;
        case 10003: return ESRCH;
        case 10004: return EINTR;
        case 10005: return EIO;
        case 10006: return ENXIO;
        case 10007: return E2BIG;
        case 10008: return ENOEXEC;
        case 10009: return EBADF;
        case 10010: return ECHILD;
        case 10011: return EAGAIN;
        case 10012: return ENOMEM;
        case 10013: return EACCES;
        case 10014: return EFAULT;
        case 10015: return ENOTBLK;
        case 10016: return EBUSY;
        case 10017: return EEXIST;
        case 10018: return EXDEV;
        case 10019: return ENODEV;
        case 10020: return ENOTDIR;
        case 10021: return EISDIR;
        case 10022: return EINVAL;
        case 10023: return ENFILE;
        case 10024: return EMFILE;
        case 10025: return ENOTTY;
        case 10026: return ETXTBSY;
        case 10027: return EFBIG;
        case 10028: return ENOSPC;
        case 10029: return ESPIPE;
        case 10030: return EROFS;
        case 10031: return EMLINK;
        case 10032: return EPIPE;
        case 10033: return EDOM;
        case 10034: return ERANGE;
        case 10035: return EDEADLK;
        case 10036: return ENAMETOOLONG;
        case 10037: return ENOLCK;
        case 10038: return ENOSYS;
        case 10039: return ENOTEMPTY;
        case 10040: return ELOOP;
        case 10042: return ENOMSG;
        case 10043: return EIDRM;
        case 10044: return ECHRNG;
        case 10045: return EL2NSYNC;
        case 10046: return EL3HLT;
        case 10047: return EL3RST;
        case 10048: return ELNRNG;
        case 10049: return EUNATCH;
        case 10050: return ENOCSI;
        case 10051: return EL2HLT;
        case 10052: return EBADE;
        case 10053: return EBADR;
        case 10054: return EXFULL;
        case 10055: return ENOANO;
        case 10056: return EBADRQC;
        case 10057: return EBADSLT;
        case 10059: return EBFONT;
        case 10060: return ENOSTR;
        case 10061: return ENODATA;
        case 10062: return ETIME;
        case 10063: return ENOSR;
        case 10064: return ENONET;
        case 10065: return ENOPKG;
        case 10066: return EREMOTE;
        case 10067: return ENOLINK;
        case 10068: return EADV;
        case 10069: return ESRMNT;
        case 10070: return ECOMM;
        case 10071: return EPROTO;
        case 10072: return EMULTIHOP;
        case 10073: return EDOTDOT;
        case 10074: return EBADMSG;
        case 10075: return EOVERFLOW;
        case 10076: return ENOTUNIQ;
        case 10077: return EBADFD;
        case 10078: return EREMCHG;
        case 10079: return ELIBACC;
        case 10080: return ELIBBAD;
        case 10081: return ELIBSCN;
        case 10082: return ELIBMAX;
        case 10083: return ELIBEXEC;
        case 10084: return EILSEQ;
        case 10085: return ERESTART;
        case 10086: return ESTRPIPE;
        case 10087: return EUSERS;
        case 10088: return ENOTSOCK;
        case 10089: return EDESTADDRREQ;
        case 10090: return EMSGSIZE;
        case 10091: return EPROTOTYPE;
        case 10092: return ENOPROTOOPT;
        case 10093: return EPROTONOSUPPORT;
        case 10094: return ESOCKTNOSUPPORT;
        case 10095: return EOPNOTSUPP;
        case 10096: return EPFNOSUPPORT;
        case 10097: return EAFNOSUPPORT;
        case 10098: return EADDRINUSE;
        case 10099: return EADDRNOTAVAIL;
        case 10100: return ENETDOWN;
        case 10101: return ENETUNREACH;
        case 10102: return ENETRESET;
        case 10103: return ECONNABORTED;
        case 10104: return ECONNRESET;
        case 10105: return ENOBUFS;
        case 10106: return EISCONN;
        case 10107: return ENOTCONN;
        case 10108: return ESHUTDOWN;
        case 10109: return ETOOMANYREFS;
        case 10110: return ETIMEDOUT;
        case 10111: return ECONNREFUSED;
        case 10112: return EHOSTDOWN;
        case 10113: return EHOSTUNREACH;
        case 10114: return EALREADY;
        case 10115: return EINPROGRESS;
        case 10116: return ESTALE;
        case 10117: return EUCLEAN;
        case 10118: return ENOTNAM;
        case 10119: return ENAVAIL;
        case 10120: return EISNAM;
        case 10121: return EREMOTEIO;
        case 10122: return EDQUOT;
        case 10123: return ENOMEDIUM;
        case 10124: return EMEDIUMTYPE;
        case 10125: return ECANCELED;
        case 10126: return ENOKEY;
        case 10127: return EKEYEXPIRED;
        case 10128: return EKEYREVOKED;
        case 10129: return EKEYREJECTED;
        case 10130: return EOWNERDEAD;
        case 10131: return ENOTRECOVERABLE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ResultCode>() {
            public ResultCode findValueByNumber(int number) {
              return ResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.apache.tajo.error.Errors.getDescriptor().getEnumTypes().get(0);
    }

    private static final ResultCode[] VALUES = values();

    public static ResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:tajo.error.ResultCode)
  }

  public interface SerializedExceptionOrBuilder
      extends com.google.protobuf.MessageOrBuilder {

    // required int64 timestamp = 1;
    /**
     * <code>required int64 timestamp = 1;</code>
     *
     * <pre>
     * Microseconds since Epoch.
     * </pre>
     */
    boolean hasTimestamp();
    /**
     * <code>required int64 timestamp = 1;</code>
     *
     * <pre>
     * Microseconds since Epoch.
     * </pre>
     */
    long getTimestamp();

    // required .tajo.error.ResultCode return_code = 2;
    /**
     * <code>required .tajo.error.ResultCode return_code = 2;</code>
     */
    boolean hasReturnCode();
    /**
     * <code>required .tajo.error.ResultCode return_code = 2;</code>
     */
    org.apache.tajo.error.Errors.ResultCode getReturnCode();

    // required string message = 3;
    /**
     * <code>required string message = 3;</code>
     */
    boolean hasMessage();
    /**
     * <code>required string message = 3;</code>
     */
    java.lang.String getMessage();
    /**
     * <code>required string message = 3;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();

    // optional .tajo.error.StackTrace stack_trace = 4;
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    boolean hasStackTrace();
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    org.apache.tajo.error.Stacktrace.StackTrace getStackTrace();
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    org.apache.tajo.error.Stacktrace.StackTraceOrBuilder getStackTraceOrBuilder();
  }
  /**
   * Protobuf type {@code tajo.error.SerializedException}
   */
  public static final class SerializedException extends
      com.google.protobuf.GeneratedMessage
      implements SerializedExceptionOrBuilder {
    // Use SerializedException.newBuilder() to construct.
    private SerializedException(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private SerializedException(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final SerializedException defaultInstance;
    public static SerializedException getDefaultInstance() {
      return defaultInstance;
    }

    public SerializedException getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private SerializedException(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              timestamp_ = input.readInt64();
              break;
            }
            case 16: {
              int rawValue = input.readEnum();
              org.apache.tajo.error.Errors.ResultCode value = org.apache.tajo.error.Errors.ResultCode.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(2, rawValue);
              } else {
                bitField0_ |= 0x00000002;
                returnCode_ = value;
              }
              break;
            }
            case 26: {
              bitField0_ |= 0x00000004;
              message_ = input.readBytes();
              break;
            }
            case 34: {
              org.apache.tajo.error.Stacktrace.StackTrace.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = stackTrace_.toBuilder();
              }
              stackTrace_ = input.readMessage(org.apache.tajo.error.Stacktrace.StackTrace.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(stackTrace_);
                stackTrace_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.apache.tajo.error.Errors.internal_static_tajo_error_SerializedException_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.apache.tajo.error.Errors.internal_static_tajo_error_SerializedException_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.apache.tajo.error.Errors.SerializedException.class, org.apache.tajo.error.Errors.SerializedException.Builder.class);
    }

    public static com.google.protobuf.Parser<SerializedException> PARSER =
        new com.google.protobuf.AbstractParser<SerializedException>() {
      public SerializedException parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SerializedException(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<SerializedException> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    // required int64 timestamp = 1;
    public static final int TIMESTAMP_FIELD_NUMBER = 1;
    private long timestamp_;
    /**
     * <code>required int64 timestamp = 1;</code>
     *
     * <pre>
     * Microseconds since Epoch.
     * </pre>
     */
    public boolean hasTimestamp() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required int64 timestamp = 1;</code>
     *
     * <pre>
     * Microseconds since Epoch.
     * </pre>
     */
    public long getTimestamp() {
      return timestamp_;
    }

    // required .tajo.error.ResultCode return_code = 2;
    public static final int RETURN_CODE_FIELD_NUMBER = 2;
    private org.apache.tajo.error.Errors.ResultCode returnCode_;
    /**
     * <code>required .tajo.error.ResultCode return_code = 2;</code>
     */
    public boolean hasReturnCode() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required .tajo.error.ResultCode return_code = 2;</code>
     */
    public org.apache.tajo.error.Errors.ResultCode getReturnCode() {
      return returnCode_;
    }

    // required string message = 3;
    public static final int MESSAGE_FIELD_NUMBER = 3;
    private java.lang.Object message_;
    /**
     * <code>required string message = 3;</code>
     */
    public boolean hasMessage() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>required string message = 3;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          message_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string message = 3;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    // optional .tajo.error.StackTrace stack_trace = 4;
    public static final int STACK_TRACE_FIELD_NUMBER = 4;
    private org.apache.tajo.error.Stacktrace.StackTrace stackTrace_;
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    public boolean hasStackTrace() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    public org.apache.tajo.error.Stacktrace.StackTrace getStackTrace() {
      return stackTrace_;
    }
    /**
     * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
     */
    public org.apache.tajo.error.Stacktrace.StackTraceOrBuilder getStackTraceOrBuilder() {
      return stackTrace_;
    }

    private void initFields() {
      timestamp_ = 0L;
      returnCode_ = org.apache.tajo.error.Errors.ResultCode.OK;
      message_ = "";
      stackTrace_ = org.apache.tajo.error.Stacktrace.StackTrace.getDefaultInstance();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized != -1) return isInitialized == 1;

      if (!hasTimestamp()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasReturnCode()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasMessage()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt64(1, timestamp_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeEnum(2, returnCode_.getNumber());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, getMessageBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, stackTrace_);
      }
      getUnknownFields().writeTo(output);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, timestamp_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, returnCode_.getNumber());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, getMessageBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, stackTrace_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static org.apache.tajo.error.Errors.SerializedException parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(org.apache.tajo.error.Errors.SerializedException prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code tajo.error.SerializedException}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder>
       implements org.apache.tajo.error.Errors.SerializedExceptionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.apache.tajo.error.Errors.internal_static_tajo_error_SerializedException_descriptor;
      }

      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.apache.tajo.error.Errors.internal_static_tajo_error_SerializedException_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.apache.tajo.error.Errors.SerializedException.class, org.apache.tajo.error.Errors.SerializedException.Builder.class);
      }

      // Construct using org.apache.tajo.error.Errors.SerializedException.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getStackTraceFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        timestamp_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        returnCode_ = org.apache.tajo.error.Errors.ResultCode.OK;
        bitField0_ = (bitField0_ & ~0x00000002);
        message_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        if (stackTraceBuilder_ == null) {
          stackTrace_ = org.apache.tajo.error.Stacktrace.StackTrace.getDefaultInstance();
        } else {
          stackTraceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.apache.tajo.error.Errors.internal_static_tajo_error_SerializedException_descriptor;
      }

      public org.apache.tajo.error.Errors.SerializedException getDefaultInstanceForType() {
        return org.apache.tajo.error.Errors.SerializedException.getDefaultInstance();
      }

      public org.apache.tajo.error.Errors.SerializedException build() {
        org.apache.tajo.error.Errors.SerializedException result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public org.apache.tajo.error.Errors.SerializedException buildPartial() {
        org.apache.tajo.error.Errors.SerializedException result = new org.apache.tajo.error.Errors.SerializedException(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.timestamp_ = timestamp_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.returnCode_ = returnCode_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.message_ = message_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        if (stackTraceBuilder_ == null) {
          result.stackTrace_ = stackTrace_;
        } else {
          result.stackTrace_ = stackTraceBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.apache.tajo.error.Errors.SerializedException) {
          return mergeFrom((org.apache.tajo.error.Errors.SerializedException)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.apache.tajo.error.Errors.SerializedException other) {
        if (other == org.apache.tajo.error.Errors.SerializedException.getDefaultInstance()) return this;
        if (other.hasTimestamp()) {
          setTimestamp(other.getTimestamp());
        }
        if (other.hasReturnCode()) {
          setReturnCode(other.getReturnCode());
        }
        if (other.hasMessage()) {
          bitField0_ |= 0x00000004;
          message_ = other.message_;
          onChanged();
        }
        if (other.hasStackTrace()) {
          mergeStackTrace(other.getStackTrace());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        if (!hasTimestamp()) {
          
          return false;
        }
        if (!hasReturnCode()) {
          
          return false;
        }
        if (!hasMessage()) {
          
          return false;
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        org.apache.tajo.error.Errors.SerializedException parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (org.apache.tajo.error.Errors.SerializedException) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      // required int64 timestamp = 1;
      private long timestamp_ ;
      /**
       * <code>required int64 timestamp = 1;</code>
       *
       * <pre>
       * Microseconds since Epoch.
       * </pre>
       */
      public boolean hasTimestamp() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required int64 timestamp = 1;</code>
       *
       * <pre>
       * Microseconds since Epoch.
       * </pre>
       */
      public long getTimestamp() {
        return timestamp_;
      }
      /**
       * <code>required int64 timestamp = 1;</code>
       *
       * <pre>
       * Microseconds since Epoch.
       * </pre>
       */
      public Builder setTimestamp(long value) {
        bitField0_ |= 0x00000001;
        timestamp_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required int64 timestamp = 1;</code>
       *
       * <pre>
       * Microseconds since Epoch.
       * </pre>
       */
      public Builder clearTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000001);
        timestamp_ = 0L;
        onChanged();
        return this;
      }

      // required .tajo.error.ResultCode return_code = 2;
      private org.apache.tajo.error.Errors.ResultCode returnCode_ = org.apache.tajo.error.Errors.ResultCode.OK;
      /**
       * <code>required .tajo.error.ResultCode return_code = 2;</code>
       */
      public boolean hasReturnCode() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required .tajo.error.ResultCode return_code = 2;</code>
       */
      public org.apache.tajo.error.Errors.ResultCode getReturnCode() {
        return returnCode_;
      }
      /**
       * <code>required .tajo.error.ResultCode return_code = 2;</code>
       */
      public Builder setReturnCode(org.apache.tajo.error.Errors.ResultCode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        returnCode_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required .tajo.error.ResultCode return_code = 2;</code>
       */
      public Builder clearReturnCode() {
        bitField0_ = (bitField0_ & ~0x00000002);
        returnCode_ = org.apache.tajo.error.Errors.ResultCode.OK;
        onChanged();
        return this;
      }

      // required string message = 3;
      private java.lang.Object message_ = "";
      /**
       * <code>required string message = 3;</code>
       */
      public boolean hasMessage() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>required string message = 3;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          java.lang.String s = ((com.google.protobuf.ByteString) ref)
              .toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string message = 3;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string message = 3;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>required string message = 3;</code>
       */
      public Builder clearMessage() {
        bitField0_ = (bitField0_ & ~0x00000004);
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <code>required string message = 3;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        message_ = value;
        onChanged();
        return this;
      }

      // optional .tajo.error.StackTrace stack_trace = 4;
      private org.apache.tajo.error.Stacktrace.StackTrace stackTrace_ = org.apache.tajo.error.Stacktrace.StackTrace.getDefaultInstance();
      private com.google.protobuf.SingleFieldBuilder<
          org.apache.tajo.error.Stacktrace.StackTrace, org.apache.tajo.error.Stacktrace.StackTrace.Builder, org.apache.tajo.error.Stacktrace.StackTraceOrBuilder> stackTraceBuilder_;
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public boolean hasStackTrace() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public org.apache.tajo.error.Stacktrace.StackTrace getStackTrace() {
        if (stackTraceBuilder_ == null) {
          return stackTrace_;
        } else {
          return stackTraceBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public Builder setStackTrace(org.apache.tajo.error.Stacktrace.StackTrace value) {
        if (stackTraceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          stackTrace_ = value;
          onChanged();
        } else {
          stackTraceBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public Builder setStackTrace(
          org.apache.tajo.error.Stacktrace.StackTrace.Builder builderForValue) {
        if (stackTraceBuilder_ == null) {
          stackTrace_ = builderForValue.build();
          onChanged();
        } else {
          stackTraceBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public Builder mergeStackTrace(org.apache.tajo.error.Stacktrace.StackTrace value) {
        if (stackTraceBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008) &&
              stackTrace_ != org.apache.tajo.error.Stacktrace.StackTrace.getDefaultInstance()) {
            stackTrace_ =
              org.apache.tajo.error.Stacktrace.StackTrace.newBuilder(stackTrace_).mergeFrom(value).buildPartial();
          } else {
            stackTrace_ = value;
          }
          onChanged();
        } else {
          stackTraceBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public Builder clearStackTrace() {
        if (stackTraceBuilder_ == null) {
          stackTrace_ = org.apache.tajo.error.Stacktrace.StackTrace.getDefaultInstance();
          onChanged();
        } else {
          stackTraceBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public org.apache.tajo.error.Stacktrace.StackTrace.Builder getStackTraceBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getStackTraceFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      public org.apache.tajo.error.Stacktrace.StackTraceOrBuilder getStackTraceOrBuilder() {
        if (stackTraceBuilder_ != null) {
          return stackTraceBuilder_.getMessageOrBuilder();
        } else {
          return stackTrace_;
        }
      }
      /**
       * <code>optional .tajo.error.StackTrace stack_trace = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.apache.tajo.error.Stacktrace.StackTrace, org.apache.tajo.error.Stacktrace.StackTrace.Builder, org.apache.tajo.error.Stacktrace.StackTraceOrBuilder> 
          getStackTraceFieldBuilder() {
        if (stackTraceBuilder_ == null) {
          stackTraceBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.apache.tajo.error.Stacktrace.StackTrace, org.apache.tajo.error.Stacktrace.StackTrace.Builder, org.apache.tajo.error.Stacktrace.StackTraceOrBuilder>(
                  stackTrace_,
                  getParentForChildren(),
                  isClean());
          stackTrace_ = null;
        }
        return stackTraceBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:tajo.error.SerializedException)
    }

    static {
      defaultInstance = new SerializedException(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:tajo.error.SerializedException)
  }

  private static com.google.protobuf.Descriptors.Descriptor
    internal_static_tajo_error_SerializedException_descriptor;
  private static
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_tajo_error_SerializedException_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\014errors.proto\022\ntajo.error\032\020stacktrace.p" +
      "roto\"\223\001\n\023SerializedException\022\021\n\ttimestam" +
      "p\030\001 \002(\003\022+\n\013return_code\030\002 \002(\0162\026.tajo.erro" +
      "r.ResultCode\022\017\n\007message\030\003 \002(\t\022+\n\013stack_t" +
      "race\030\004 \001(\0132\026.tajo.error.StackTrace*\313!\n\nR" +
      "esultCode\022\006\n\002OK\020\000\022\013\n\007WARNING\020d\022\023\n\016INTERN" +
      "AL_ERROR\020\311\001\022\024\n\017NOT_IMPLEMENTED\020\312\001\022\032\n\025FEA" +
      "TURE_NOT_SUPPORTED\020\313\001\022\025\n\020INVALID_RPC_CAL" +
      "L\020\314\001\022\021\n\014QUERY_FAILED\020\255\002\022\021\n\014QUERY_KILLED\020" +
      "\256\002\022\022\n\rQUERY_TIMEOUT\020\257\002\022\024\n\017QUERY_NOT_FOUN",
      "D\020\260\002\022\014\n\007NO_DATA\020\261\002\022\025\n\020INCOMPLETE_QUERY\020\262" +
      "\002\022\024\n\017INVALID_SESSION\020\221\003\022\035\n\030NO_SUCH_SESSI" +
      "ON_VARIABLE\020\222\003\022\035\n\030INVALID_SESSION_VARIAB" +
      "LE\020\223\003\022\025\n\020DIVISION_BY_ZERO\020\303\003\022\033\n\026INVALID_" +
      "VALUE_FOR_CAST\020\304\003\022\020\n\013INVALID_URL\020\305\003\022*\n%S" +
      "YNTAX_ERROR_OR_ACCESS_RULE_VIOLATION\020\365\003\022" +
      "\021\n\014SYNTAX_ERROR\020\366\003\022\033\n\026INSUFFICIENT_PRIVI" +
      "LEGE\020\367\003\022!\n\034CANNOT_DROP_CURRENT_DATABASE\020" +
      "\370\003\022\031\n\024UNDEFINED_TABLESPACE\020\377\003\022\027\n\022UNDEFIN" +
      "ED_DATABASE\020\200\004\022\025\n\020UNDEFINED_SCHEMA\020\201\004\022\024\n",
      "\017UNDEFINED_TABLE\020\202\004\022\025\n\020UNDEFINED_COLUMN\020" +
      "\203\004\022\027\n\022UNDEFINED_FUNCTION\020\204\004\022\036\n\031UNDEFINED" +
      "_INDEX_FOR_TABLE\020\205\004\022 \n\033UNDEFINED_INDEX_F" +
      "OR_COLUMNS\020\206\004\022\031\n\024UNDEFINED_INDEX_NAME\020\207\004" +
      "\022\030\n\023UNDEFINED_PARTITION\020\210\004\022\037\n\032UNDEFINED_" +
      "PARTITION_METHOD\020\211\004\022\027\n\022UNDEFINED_OPERATO" +
      "R\020\212\004\022\034\n\027UNDEFINED_PARTITION_KEY\020\213\004\022!\n\034UN" +
      "DEFINED_TABLESPACE_HANDLER\020\214\004\022\031\n\024UNDEFIN" +
      "ED_PARTITIONS\020\215\004\022\031\n\024DUPLICATE_TABLESPACE" +
      "\020\223\004\022\027\n\022DUPLICATE_DATABASE\020\224\004\022\025\n\020DUPLICAT",
      "E_SCHEMA\020\225\004\022\024\n\017DUPLICATE_TABLE\020\226\004\022\025\n\020DUP" +
      "LICATE_COLUMN\020\227\004\022\024\n\017DUPLICATE_ALIAS\020\230\004\022\027" +
      "\n\022DUPLICATE_FUNCTION\020\231\004\022\024\n\017DUPLICATE_IND" +
      "EX\020\232\004\022\030\n\023DUPLICATE_PARTITION\020\233\004\022\024\n\017AMBIG" +
      "UOUS_TABLE\020\235\004\022\025\n\020AMBIGUOUS_COLUMN\020\236\004\022\027\n\022" +
      "AMBIGUOUS_FUNCTION\020\237\004\022\"\n\035AMBIGUOUS_PARTI" +
      "TION_DIRECTORY\020\240\004\022\020\n\013CANNOT_CAST\020\331\004\022\023\n\016G" +
      "ROUPING_ERROR\020\332\004\022\024\n\017WINDOWING_ERROR\020\333\004\022\026" +
      "\n\021INVALID_RECURSION\020\334\004\022\"\n\035SET_OPERATION_" +
      "SCHEMA_MISMATCH\020\335\004\022$\n\037SET_OPERATION_DATA",
      "TYPE_MISMATCH\020\336\004\022\030\n\023INVALID_FOREIGN_KEY\020" +
      "\355\004\022\021\n\014INVALID_NAME\020\356\004\022\036\n\031INVALID_COLUMN_" +
      "DEFINITION\020\357\004\022\022\n\rNAME_TOO_LONG\020\360\004\022\022\n\rRES" +
      "ERVED_NAME\020\361\004\022\026\n\021DATATYPE_MISMATCH\020\362\004\022\033\n" +
      "\026INDETERMINATE_DATATYPE\020\363\004\022\027\n\022INVALID_EX" +
      "PRESSION\020\275\005\022\025\n\020INVALID_DATATYPE\020\277\005\022\025\n\020NU" +
      "MERIC_OVERFLOW\020\243\006\022 \n\033VALUE_LARGER_THAN_P" +
      "RECISION\020\244\006\022\031\n\024CAT_UPGRADE_REQUIRED\020\205\007\022\027" +
      "\n\022CAT_CANNOT_CONNECT\020\206\007\022\"\n\035CAT_UNSUPPORT" +
      "ED_CATALOG_STORE\020\211\007\022\034\n\027LMD_NO_MATCHED_DA",
      "TATYPE\020\216\007\022\037\n\032UNAVAILABLE_TABLE_LOCATION\020" +
      "\351\007\022\027\n\022UNKNOWN_DATAFORMAT\020\352\007\022\031\n\024UNSUPPORT" +
      "ED_DATATYPE\020\353\007\022\033\n\026INVALID_TABLE_PROPERTY" +
      "\020\354\007\022\033\n\026MISSING_TABLE_PROPERTY\020\355\007\022 \n\033CLIE" +
      "NT_CONNECTION_EXCEPTION\020\315\010\022%\n CLIENT_CON" +
      "NECTION_DOES_NOT_EXIST\020\317\010\022*\n%CLIENT_UNAB" +
      "LE_TO_ESTABLISH_CONNECTION\020\316\010\022\'\n\"CLIENT_" +
      "PROTOCOL_PROTOCOL_VIOLATION\020\320\010\022\033\n\025INSUFF" +
      "ICIENT_RESOURCE\020\210\236\003\022\017\n\tDISK_FULL\020\354\236\003\022\023\n\r" +
      "OUT_OF_MEMORY\020\320\237\003\022\034\n\026PROGRAM_LIMIT_EXCEE",
      "DED\020\360\245\003\022\033\n\025STATEMENT_TOO_COMPLEX\020\361\245\003\022\037\n\031" +
      "STRING_CONSTANT_TOOL_LONG\020\362\245\003\022$\n\036TOO_LAR" +
      "GE_INPUT_FOR_CROSS_JOIN\020\363\245\003\022#\n\035INVALID_I" +
      "NPUTS_FOR_CROSS_JOIN\020\364\245\003\022\025\n\017TOO_MANY_TAB" +
      "LES\020\366\245\003\022\026\n\020TOO_MANY_COLUMNS\020\373\245\003\022\030\n\022TOO_M" +
      "ANY_ARGUMENTS\020\207\246\003\022\016\n\010IO_ERROR\020\256\305\003\022\n\n\005EPE" +
      "RM\020\221N\022\013\n\006ENOENT\020\222N\022\n\n\005ESRCH\020\223N\022\n\n\005EINTR\020" +
      "\224N\022\010\n\003EIO\020\225N\022\n\n\005ENXIO\020\226N\022\n\n\005E2BIG\020\227N\022\014\n\007" +
      "ENOEXEC\020\230N\022\n\n\005EBADF\020\231N\022\013\n\006ECHILD\020\232N\022\013\n\006E" +
      "AGAIN\020\233N\022\013\n\006ENOMEM\020\234N\022\013\n\006EACCES\020\235N\022\013\n\006EF",
      "AULT\020\236N\022\014\n\007ENOTBLK\020\237N\022\n\n\005EBUSY\020\240N\022\013\n\006EEX" +
      "IST\020\241N\022\n\n\005EXDEV\020\242N\022\013\n\006ENODEV\020\243N\022\014\n\007ENOTD" +
      "IR\020\244N\022\013\n\006EISDIR\020\245N\022\013\n\006EINVAL\020\246N\022\013\n\006ENFIL" +
      "E\020\247N\022\013\n\006EMFILE\020\250N\022\013\n\006ENOTTY\020\251N\022\014\n\007ETXTBS" +
      "Y\020\252N\022\n\n\005EFBIG\020\253N\022\013\n\006ENOSPC\020\254N\022\013\n\006ESPIPE\020" +
      "\255N\022\n\n\005EROFS\020\256N\022\013\n\006EMLINK\020\257N\022\n\n\005EPIPE\020\260N\022" +
      "\t\n\004EDOM\020\261N\022\013\n\006ERANGE\020\262N\022\014\n\007EDEADLK\020\263N\022\021\n" +
      "\014ENAMETOOLONG\020\264N\022\013\n\006ENOLCK\020\265N\022\013\n\006ENOSYS\020" +
      "\266N\022\016\n\tENOTEMPTY\020\267N\022\n\n\005ELOOP\020\270N\022\013\n\006ENOMSG" +
      "\020\272N\022\n\n\005EIDRM\020\273N\022\013\n\006ECHRNG\020\274N\022\r\n\010EL2NSYNC",
      "\020\275N\022\013\n\006EL3HLT\020\276N\022\013\n\006EL3RST\020\277N\022\013\n\006ELNRNG\020" +
      "\300N\022\014\n\007EUNATCH\020\301N\022\013\n\006ENOCSI\020\302N\022\013\n\006EL2HLT\020" +
      "\303N\022\n\n\005EBADE\020\304N\022\n\n\005EBADR\020\305N\022\013\n\006EXFULL\020\306N\022" +
      "\013\n\006ENOANO\020\307N\022\014\n\007EBADRQC\020\310N\022\014\n\007EBADSLT\020\311N" +
      "\022\013\n\006EBFONT\020\313N\022\013\n\006ENOSTR\020\314N\022\014\n\007ENODATA\020\315N" +
      "\022\n\n\005ETIME\020\316N\022\n\n\005ENOSR\020\317N\022\013\n\006ENONET\020\320N\022\013\n" +
      "\006ENOPKG\020\321N\022\014\n\007EREMOTE\020\322N\022\014\n\007ENOLINK\020\323N\022\t" +
      "\n\004EADV\020\324N\022\013\n\006ESRMNT\020\325N\022\n\n\005ECOMM\020\326N\022\013\n\006EP" +
      "ROTO\020\327N\022\016\n\tEMULTIHOP\020\330N\022\014\n\007EDOTDOT\020\331N\022\014\n" +
      "\007EBADMSG\020\332N\022\016\n\tEOVERFLOW\020\333N\022\r\n\010ENOTUNIQ\020",
      "\334N\022\013\n\006EBADFD\020\335N\022\014\n\007EREMCHG\020\336N\022\014\n\007ELIBACC" +
      "\020\337N\022\014\n\007ELIBBAD\020\340N\022\014\n\007ELIBSCN\020\341N\022\014\n\007ELIBM" +
      "AX\020\342N\022\r\n\010ELIBEXEC\020\343N\022\013\n\006EILSEQ\020\344N\022\r\n\010ERE" +
      "START\020\345N\022\r\n\010ESTRPIPE\020\346N\022\013\n\006EUSERS\020\347N\022\r\n\010" +
      "ENOTSOCK\020\350N\022\021\n\014EDESTADDRREQ\020\351N\022\r\n\010EMSGSI" +
      "ZE\020\352N\022\017\n\nEPROTOTYPE\020\353N\022\020\n\013ENOPROTOOPT\020\354N" +
      "\022\024\n\017EPROTONOSUPPORT\020\355N\022\024\n\017ESOCKTNOSUPPOR" +
      "T\020\356N\022\017\n\nEOPNOTSUPP\020\357N\022\021\n\014EPFNOSUPPORT\020\360N" +
      "\022\021\n\014EAFNOSUPPORT\020\361N\022\017\n\nEADDRINUSE\020\362N\022\022\n\r" +
      "EADDRNOTAVAIL\020\363N\022\r\n\010ENETDOWN\020\364N\022\020\n\013ENETU",
      "NREACH\020\365N\022\016\n\tENETRESET\020\366N\022\021\n\014ECONNABORTE" +
      "D\020\367N\022\017\n\nECONNRESET\020\370N\022\014\n\007ENOBUFS\020\371N\022\014\n\007E" +
      "ISCONN\020\372N\022\r\n\010ENOTCONN\020\373N\022\016\n\tESHUTDOWN\020\374N" +
      "\022\021\n\014ETOOMANYREFS\020\375N\022\016\n\tETIMEDOUT\020\376N\022\021\n\014E" +
      "CONNREFUSED\020\377N\022\016\n\tEHOSTDOWN\020\200O\022\021\n\014EHOSTU" +
      "NREACH\020\201O\022\r\n\010EALREADY\020\202O\022\020\n\013EINPROGRESS\020" +
      "\203O\022\013\n\006ESTALE\020\204O\022\014\n\007EUCLEAN\020\205O\022\014\n\007ENOTNAM" +
      "\020\206O\022\014\n\007ENAVAIL\020\207O\022\013\n\006EISNAM\020\210O\022\016\n\tEREMOT" +
      "EIO\020\211O\022\013\n\006EDQUOT\020\212O\022\016\n\tENOMEDIUM\020\213O\022\020\n\013E" +
      "MEDIUMTYPE\020\214O\022\016\n\tECANCELED\020\215O\022\013\n\006ENOKEY\020",
      "\216O\022\020\n\013EKEYEXPIRED\020\217O\022\020\n\013EKEYREVOKED\020\220O\022\021" +
      "\n\014EKEYREJECTED\020\221O\022\017\n\nEOWNERDEAD\020\222O\022\024\n\017EN" +
      "OTRECOVERABLE\020\223OB\027\n\025org.apache.tajo.erro" +
      "r"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          internal_static_tajo_error_SerializedException_descriptor =
            getDescriptor().getMessageTypes().get(0);
          internal_static_tajo_error_SerializedException_fieldAccessorTable = new
            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
              internal_static_tajo_error_SerializedException_descriptor,
              new java.lang.String[] { "Timestamp", "ReturnCode", "Message", "StackTrace", });
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          org.apache.tajo.error.Stacktrace.getDescriptor(),
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
